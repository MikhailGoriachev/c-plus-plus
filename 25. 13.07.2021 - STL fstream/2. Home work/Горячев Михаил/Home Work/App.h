#pragma once
#include "pch.h"
#include "Utils.h"

#include "menu.h"
#include "MenuItem.h"

#include "BinaryTree.h"
#include "DblList.h"
#include "Person.h"

/*
 * 	Разработать консольное приложение, с использованием класса Person, двусвязного
 *	списка (класс DblList<Person>)объектов класса Person. Примените функциональные 
 *	try-блоки в конструкторах класса Person.
 * 
 *	Класс Person имеет поля:
 *		Табельный номер, целое число, уникальное в пределах приложения
 *		Фамилия и инициалы – динамическое поле, char *
 *		Оклад, вещественное число
 *		Год поступления на работу
 *		Количество рабочих дней в месяце
 *		Количество фактически отработанных дней в месяце
 *	Разработать конструкторы и деструктор, аксессоры, метод записи полей в 
 *	форматированный поток вывода, метод чтения полей из форматированного потока ввода,
 *	метод записи в бинарный поток вывода, метод чтения из бинарного потока ввода, метод
 *	вычисления начислений –произведение оклада на отношение количества фактически 
 *	отработанных дней к количеству рабочих дней в месяце.
 *	Начислено=Оклад∙ (Фактически отработано)/(Рабочих дней в месяце)
 *	  — Создать двусвязный список из объектов класса Person–не менее 12 элементов, 
 *		показать работу конструкторов, методов, генерацию и обработку исключений.
 *	  —	Разработать функцию, вычисляющую сумму начислений по двусвязному списку персон
 *	  —	Сохранить двусвязный список в текстовом файле с использованием форматированного
 *		потока записи, формат вывода в поток одного элемента списка:
 *			Первая строка – табельный номер
 *			Вторая строка – фамилия и инициалы
 *			Третья строка – остальные поля данных, через пробел
 *	  —	Загрузить из записанного файла в другой двусвязный список записи с окладом в 
 *		заданном диапазоне значений. Использовать форматированный файловый поток чтения.
 *	  —	Выгрузить двусвязный список персон в файл при помощи бинарного потока вывода ofstream.
 *	  —	Прочитать из бинарного файла при помощи бинарного потока ввода ifstream и в односвязный
 *		список записи и отобразить этот односвязный список в консоли.
*/

// TODO: прикладная часть - полезная работа приложения - бизнес-логика приложения
class App
{
public:

	// длина массива для заполнения 
	static const int SIZE_FILL_ARR = 12;

private:

	// база табельных номеров класса Person
	BinaryTree<unsigned int> numberBase_;

	// двусвязный список из объектов класса Person
	DblList<Person> list_;

	// список персон для списка 
	Person* personsByList_;

public:

	// конструктор по умолчанию
	App()
	{
		// 	Person(unsigned int number, const char* name, double salary, int year, int monthWorkDay, int completedWorkDay) try

		// список персон
		personsByList_ = new Person[SIZE_FILL_ARR]
		{
			Person(654878, "Бобров В.Б", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
			Person(987521, "Иванов Н.Г", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
			Person(345987, "Дьячков В.Ф", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
			Person(567442, "Тарасов Н.Х", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
			Person(654574, "Шашков Г.Л", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
			Person(324957, "Лобанов И.С", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
			Person(687684, "Третьяков О.Х", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
			Person(795215, "Бирюков М.М", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
			Person(564957, "Игнатов Н.В", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
			Person(654212, "Логинов А.Е", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
			Person(567541, "Ситников М.В", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
			Person(245621, "Кулаков Л.Я", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
		};

		// список персон
		// personsByTree_ = new Person[SIZE_FILL_ARR]
		// {
		// 	Person(579846, "Власов А.Ф", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
		// 	Person(324987, "Данилов Г.Г", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
		// 	Person(654981, "Крылов Д.А", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
		// 	Person(789165, "Авдеев В.А", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
		// 	Person(645954, "Овчинников Р.Ф", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
		// 	Person(989234, "Архипов А.А", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
		// 	Person(651579, "Терентьев Т.А", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
		// 	Person(654621, "Емельянов Б.Г", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
		// 	Person(654653, "Александров В.Г", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
		// 	Person(216577, "Игнатов А.П", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
		// 	Person(654982, "Белов О.А", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
		// 	Person(215440, "Пестов А.Д", getRand(10, 80) * 1000, getRand(1995, 2021), getRand(15, 20), getRand(1, 15)),
		// };

	}

	// деструктор 
	~App() = default;


#pragma region Задание 1

	// Заполнение списка рабочих
	void fillPersons();

	// Генерация исключений
	void genExceptionAddList();

	// Генерация исключений при создании объекта
	void genExceptionCreate();

	// Вывод двусвязого списка
	void printList();

	// Сохранение двусвязного список в текстовый файл
	void saveText();

	// Загрузка данных из текстового файла в двусвязный список
	void loadText();

	// Сохранение двусвязного список в бинарный файл
	void saveBin();

	// Загрузка данных из бинарного файла в двусвязный список
	void loadBin();

	// сумма начислений по двусвязному списку
	double accruedAll(DblList<Person> list);

	// добавление одного элемента в список
	void addPerson(Person& person, DblList<Person> list);

	// добавление массива элементов в список
	void addAllPerson(Person* data, int n, DblList<Person> list);

	// добавление номера в базу номеров
	bool registrationNumber(unsigned int number);

	// вывод списка в виде таблицы
	void showPerson(DblList<Person> list);

#pragma endregion

};

