#include "App.h"

/*
	Разработать приложение с использованием меню для закрепления работы с деком, используйте меню.

	На основе класса Deque реализовать класс DequeChar – дек символов (тип char) на 
	динамическом массиве, размер массива задавать конструктором. По умолчанию размер – 15 символов.
		• Задание 1. Даны два непустых дека символов (char), деки заполнены русскими и латинскими буквами 
			нижнего регистра. Переместить все элементы из конца первого дека в начало второго.
		• Задание 2. Даны два непустых дека символов (char), деки заполнены русскими и латинскими буквами 
			нижнего регистра. Перемещать элементы из конца первого дека в конец второго, пока в конце
			первого дека не появится гласная буква латинского языка. Если в первом деке нет гласных 
			латинских букв, то переместить из первого дека во второй все элементы.
		• Задание 3. Дан непустой дек символов (char), дек заполнен русскими и латинскими буквами нижнего 
			регистра. Создать два новых дека, переместив с конца исходного дека в начало первого из
			них все гласные буквы, а в начало второго – все согласные.
*/

#pragma region Задания 

#pragma region Задание 1 

/*
	Задание 1. Даны два непустых дека символов (char), деки заполнены русскими и латинскими буквами
		нижнего регистра. Переместить все элементы из конца первого дека в начало второго.
*/

// Задание 1. Перемещение всех элементов из конца первой в начало второй очереди
void App::task1()
{
	cls();

	cout << "\n\n\t	Задание 1. Даны два непустых дека символов (char), деки заполнены\n"
		<< "\tрусскими и латинскими буквами нижнего регистра.Переместить все элементы\n"
		<< "\tиз конца первого дека в начало второго.\n\n\n";

	// дек первый и второй
	DequeChar deqOne(getRand(2, 6)), deqTwo(getRand(5, 7));

	// заполнение деков 
	fillDequeChar(deqOne, getRand(2, deqOne.size()));
	fillDequeChar(deqTwo, getRand(2, deqTwo.size()));

	// демонстрация деков
	cout << "\t\tДек 1 до перемещения\n"
		<< deqOne << "\n\n"
		<< "\t\tДек 2 до перемещения\n"
		<< deqTwo << "\n\n";

	// перемещение из конца первого дека в начало второго
	task1Insert(deqTwo, deqOne);

	// демонстрация деков
	cout << "\t\tДек 1 после перемещения\n"
		<< deqOne << "\n\n"
		<< "\t\tДек 2 после перемещения\n"
		<< deqTwo << "\n\n";

	getKey();
}

// перемещение элементов из конца первого дека в начало второго
void App::task1Insert(DequeChar& dest, DequeChar& source)
{
	// до тех пор пока результирующий дек не переполнен 
	// и ресурсный дек не опустошён
	while (!dest.isFull() && !source.isEmpty())
	{
		// перемещение из конца первого дека в начало второго
		dest.push(source.pop());
	}
}

#pragma endregion

#pragma region Задание 2

/*
	Задание 2. Даны два непустых дека символов (char), деки заполнены русскими и латинскими буквами 
			нижнего регистра. Перемещать элементы из конца первого дека в конец второго, пока в конце
			первого дека не появится гласная буква латинского языка. Если в первом деке нет гласных 
			латинских букв, то переместить из первого дека во второй все элементы.
*/

// Задание 2. Перемещение из конца первого в конец второго дека до гласной латинской буквы
void App::task2()
{
	cls();

	cout << "\n\n\t	Задание 2. Даны два непустых дека символов (char), деки заполнены русскими и латинскими буквами \n"
		<< "\tнижнего регистра. Перемещать элементы из конца первого дека в конец второго, пока в конце\n"
		<< "\tпервого дека не появится гласная буква латинского языка. Если в первом деке нет гласных \n"
		<< "\tлатинских букв, то переместить из первого дека во второй все элементы.\n\n\n";

	// дек первый и второй
	DequeChar deqOne(getRand(2, 6)), deqTwo(getRand(5, 7));

	// заполнение деков 
	fillDequeChar(deqOne, getRand(2, deqOne.size()));
	fillDequeChar(deqTwo, getRand(2, deqTwo.size()));

	// демонстрация деков
	cout << "\t\tДек 1 до перемещения\n"
		<< deqOne << "\n\n"
		<< "\t\tДек 2 до перемещения\n"
		<< deqTwo << "\n\n";

	// перемещение из конца первого дека в начало второго
	task1Insert(deqTwo, deqOne);

	// демонстрация деков
	cout << "\t\tДек 1 после перемещения\n"
		<< deqOne << "\n\n"
		<< "\t\tДек 2 после перемещения\n"
		<< deqTwo << "\n\n";

	getKey();

}

// перемещение из конца первого в конец второго дека до гласной латинской буквы
void App::task2Insert(DequeChar& dest, DequeChar& source)
{
	// перемещать элементы из конца первого дека в конец второго, пока в конце
	// первого дека не появится гласная буква латинского языка. 
	while (!dest.isFull() && !source.isEmpty())
	{
		// хранение элемента
		char tmp = source.back();

		// массив латинских гласных букв
		char vovel[6] = "eyuoa";

		// если символ является гласной буквой латинского языка 
		for (int i = 0; i < 6; i++)
		{
			if (tmp == vovel[i])
				return;
		}

		// перемещение из конца первого дека в начало второго
		dest.shift(source.pop());
	}
}

#pragma endregion

#pragma region Задание 3

/*
	Задание 3. Дан непустой дек символов (char), дек заполнен русскими и латинскими буквами нижнего 
			регистра. Создать два новых дека, переместив с конца исходного дека в начало первого из
			них все гласные буквы, а в начало второго – все согласные.
*/

// Задание 3. Перемещение в два дека: с гласными, с согласными
void App::task3()
{
	cls();

	cout << "\n\n\t	Задание 3. Дан непустой дек символов (char), дек заполнен русскими и латинскими буквами нижнего \n"
		<< "\tрегистра. Создать два новых дека, переместив с конца исходного дека в начало первого из\n"
		<< "\tних все гласные буквы, а в начало второго – все согласные.\n\n\n";

	// деки
	DequeChar source(getRand(4, 10)), vowel(source.size()), consonant(source.size());

	// заполнение ресурсного дека
	fillDequeChar(source, source.size());

	// демонстрация ресурсного дека
	cout << "\t\tДек Ресурс до перемещения\n"
		<< source << "\n\n"
		<< "\t\tДек Гласных до перемещения\n"
		<< vowel << "\n\n"
		<< "\t\tДек Соласных до перемещения\n"
		<< consonant << "\n\n";

	// перемещение
	task3Insert(vowel, consonant, source);

	// демонстрация ресурсного дека
	cout << "\t\tДек Ресурс после перемещения\n"
		<< source << "\n\n"
		<< "\t\tДек Гласных после перемещения\n"
		<< vowel << "\n\n"
		<< "\t\tДек Соласных после перемещения\n"
		<< consonant << "\n\n";

	getKey();
}

// перемещение в две очереди: с гласными, с согласными
void App::task3Insert(DequeChar & vowel, DequeChar & consonant, DequeChar & source)
{
	// перемещение до опустошенея ресурсного дека
	while (!source.isEmpty())
	{
		// считывание элемента 
		char tmp = source.pop();

		// строка с класными буквами латинского и русского алфавита
		char vovelStr[16] = "eyuoaёуеыаоэяию";

		// флаг на вхождение символа в массив гласных букв
		bool flag = false;

		// если буква является гласной
		for (int i = 0; i < 16; i++)
		{
			if (tmp == vovelStr[i])
			{
				vowel.shift(tmp);

				flag = true;

				break;
			}
		}

		// если символ являтся гласной буквой
		if (flag) continue;

		// если символ является согласной буквой
		consonant.shift(tmp);
	}
}


#pragma endregion

#pragma region Общие методы

// заполнение массива (char), n - количество элементов для заполнения
void App::fillDequeChar(DequeChar& dequeChar, int n)
{
	// заполнение элементов
	for (int i = 0; i < n && !dequeChar.isFull(); i++)
	{
		int n = getRand(1, 2);

		// 1 - латинская буква, 2 - русская буква
		dequeChar.push(n == 1 ? getRand('a', 'z') : getRand('а', 'я'));
	}
}

#pragma endregion


#pragma endregion