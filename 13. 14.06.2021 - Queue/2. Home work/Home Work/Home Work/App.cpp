#include "App.h"

/*
	Разработать приложение с использованием меню для закрепления работы с очередью. 
	Разработайте класс очереди QueueDbl (на основе класса Queueс кольцевым буфером, 
	из классной работы) для хранения чисел типа double. Также разработайте класс 
	очереди QueuePlane для хранения объектов класса Plane. Используйте динамический
	массив для контейнера данных, размер массива задается в конструкторе и не 
	меняется во время работы. 
	•	Задача 1. Даны две непустые очереди вещественных (double) чисел, заполненные
		случайными значениями. Переместить все элементы из первой очереди во вторую 
		(в результате элементы первой очереди будут располагаться во второй очереди 
		в исходном порядке).
	•	Задача 2. Даны две непустые очереди вещественных (double) чисел, заполненные 
		случайными значениями. Перемещать элементы из первой очереди во вторую, пока
		значение первого элемента первой очереди не станет отрицательным 
		(перемещенные элементы первой очереди будут располагаться во второй очереди 
		в исходном порядке). Если в первой очереди нет элементов с отрицательными 
		значениями, то переместить из первой очереди во вторую все элементы.
	•	Задача 3. Дана непустая очередь вещественных (double) чисел, заполненная 
		случайными значениями. Создать две новых очереди, переместив в первую из них
		все элементы исходной очереди с положительными значениями, а во вторую — с 
		отрицательными (элементы в новых очередях будут располагаться в исходном 
		порядке; одна из этих очередей может оказаться пустой).
	•	Задача 4. Дана непустая очередь QueuePlane. Переместить из этой очереди в 
		новую очередь все самолеты с заданным с клавиатуры диапазоном расхода 
		горючего. Исходная очередь не должна измениться.Можно использовать 
		вспомогательную очередь – динамическую переменную.
*/


#pragma region Задания 

#pragma region Задача 1. Перемещение элементов из одной очереди во вторую

/*		
	Задача 1. Даны две непустые очереди вещественных (double) чисел, заполненные
		случайными значениями. Переместить все элементы из первой очереди во вторую
		(в результате элементы первой очереди будут располагаться во второй очереди
		в исходном порядке).
*/

// Задача 1. Перемещение элементов из одной очереди во вторую
void App::task1()
{
	cls();

	cout << "\n\n\t\tУсловия задания 1\n" 
		<< "\tДаны две непустые очереди вещественных (double) чисел, заполненные\n"
		<< "\tслучайными значениями.Переместить все элементы из первой очереди во вторую\n"
		<< "\t(в результате элементы первой очереди будут располагаться во второй очереди\n"
		<< "\tв исходном порядке).\n\n\n";

	// очередь ресурс и стек для перемещения
	QueueDbl source(getRand(5, 10)), dest(getRand(5, 10));

	// заполненени очередей случайными числами
	fillQueueDbl(source, getRand(2, source.getSize()));
	fillQueueDbl(dest, getRand(2, dest.getSize()));

	// демонстрация очередей source, dest до перемещения 
	cout << "\tДемонстрация очередей до перемещения\n\n" 
		<< "\t\tОчередь 1\n" << source << "\n\n"
		<< "\t\tОчередь 2\n" << dest << "\n\n";
		
	// перемещение элементов
	task1Insert(source, dest);

	// демонстрация очередей source, dest после перемещения 
	cout << "\tДемонстрация очередей после перемещения\n\n"
		<< "\t\tОчередь 1\n" << source << "\n\n"
		<< "\t\tОчередь 2\n" << dest << "\n\n";

	getKey();
}

// перемещение элементов 
void App::task1Insert(QueueDbl& source, QueueDbl& dest)
{
	// перемещение элементов до опустошения очереди source
	while (!source.isEmpty() && !dest.isFull())
	{
		dest.enqueue(source.dequeue());
	}
}

#pragma endregion 

#pragma region Задача 2. Перемещение до отрицательного элемента

/*
	Задача 2. Даны две непустые очереди вещественных (double) чисел, заполненные
		случайными значениями. Перемещать элементы из первой очереди во вторую, пока
		значение первого элемента первой очереди не станет отрицательным
		(перемещенные элементы первой очереди будут располагаться во второй очереди
		в исходном порядке). Если в первой очереди нет элементов с отрицательными
		значениями, то переместить из первой очереди во вторую все элементы.
*/

// Задача 2. Перемещение до отрицательного элемента
void App::task2()
{
	cls();

	cout << "\n\n\t\tУсловия задания 1\n"
		<< "\tДаны две непустые очереди вещественных (double) чисел, заполненные\n"
		<< "\tслучайными значениями. Перемещать элементы из первой очереди во вторую, пока\n"
		<< "\t(перемещенные элементы первой очереди будут располагаться во второй очереди\n"
		<< "\tв исходном порядке). Если в первой очереди нет элементов с отрицательными\n"
		<< "\tзначениями, то переместить из первой очереди во вторую все элементы.\n\n\n";

	// очередь ресурс и стек для перемещения
	QueueDbl source(getRand(5, 7)), dest(getRand(5, 7));

	// заполненени очередей случайными числами
	fillQueueDbl(source, getRand(2, source.getSize()));
	fillQueueDbl(dest, getRand(2, dest.getSize()));

	// демонстрация очередей source, dest до перемещения 
	cout << "\tДемонстрация очередей до перемещения\n\n"
		<< "\t\tОчередь 1\n" << source << "\n\n"
		<< "\t\tОчередь 2\n" << dest << "\n\n";

	// перемещение элементов
	task2Insert(source, dest);

	// демонстрация очередей source, dest после перемещения 
	cout << "\tДемонстрация очередей после перемещения\n\n"
		<< "\t\tОчередь 1\n" << source << "\n\n"
		<< "\t\tОчередь 2\n" << dest << "\n\n";

	getKey();
}

// перемещение элементов до отрицательного элемента
void App::task2Insert(QueueDbl& source, QueueDbl& dest)
{
	// перемещение элементов до опустошения очереди source
	while (!source.isEmpty() && !dest.isFull())
	{
		// просмотр начала очереди
		double tmp = source.front();

		// если элемент tmp является отрицательным
		if (tmp < 0)
			break;

		// перемещение элемента
		dest.enqueue(source.dequeue());
	}
}


#pragma endregion

#pragma region Задача 3. Разделение очереди на отрицателньую и положительную

/*
	Задача 3. Дана непустая очередь вещественных (double) чисел, заполненная
			случайными значениями. Создать две новых очереди, переместив в первую из них
			все элементы исходной очереди с положительными значениями, а во вторую — с
			отрицательными (элементы в новых очередях будут располагаться в исходном
			порядке; одна из этих очередей может оказаться пустой).
*/

// Задача 3. Разделение очереди на отрицателньую и положительную
void App::task3()
{
	cls();

	cout << "\n\n\t\tУсловия задания 3\n"
		<< "\tДана непустая очередь вещественных (double) чисел, заполненная\n"
		<< "\tслучайными значениями. Создать две новых очереди, переместив в первую из них\n"
		<< "\tвсе элементы исходной очереди с положительными значениями, а во вторую — с\n"
		<< "\tотрицательными (элементы в новых очередях будут располагаться в исходном\n"
		<< "\tпорядке; одна из этих очередей может оказаться пустой).\n\n\n";

	// очередь ресурс, отрицательная и положительная
	QueueDbl source(getRand(5, 7)), neg(source.getSize()), pos(source.getSize());

	// заполненени очередей случайными числами
	fillQueueDbl(source, source.getSize());

	// демонстрация очередей source, dest до перемещения 
	cout << "\tДемонстрация очередей до перемещения\n\n"
		<< "\t\tОчередь ресурс\n" << source << "\n\n"
		<< "\t\tПоложительная очередь\n" << pos << "\n\n"
		<< "\t\tОтрицательная очередь\n" << neg << "\n\n";

	// перемещение элементов
	task3Insert(source, pos, neg);

	// демонстрация очередей source, dest после перемещения 
	cout << "\tДемонстрация очередей после перемещения\n\n"
		<< "\t\tОчередь ресурс\n" << source << "\n\n"
		<< "\t\tПоложительная очередь\n" << pos << "\n\n"
		<< "\t\tОтрицательная очередь\n" << neg << "\n\n";

	getKey();
}

// перемещение элементов в две очереди: отрицательную и положительную
void App::task3Insert(QueueDbl& source, QueueDbl& pos, QueueDbl& neg)
{
	// перемещение элементов до опустошения очереди source
	while (!source.isEmpty())
	{
		// просмотр начала очереди
		double tmp = source.dequeue();

		// если элемент tmp является отрицательным или положительным
		tmp >= 0 ? pos.enqueue(tmp) : neg.enqueue(tmp);
	}
}

#pragma endregion

#pragma region Задача 4. Перемещение самолётов по диапазону расхода горючего

/*
	 Задача 4. Дана непустая очередь QueuePlane. Переместить из этой очереди в
			новую очередь все самолеты с заданным с клавиатуры диапазоном расхода
			горючего. Исходная очередь не должна измениться.Можно использовать
			вспомогательную очередь – динамическую переменную.
*/

// Задача 4. Перемещение самолётов по диапазону расхода горючего
void App::task4()
{
	cls();

	cout << "\n\n\t\tУсловия задания 4\n"
		<< "\tДана непустая очередь QueuePlane. Переместить из этой очереди в\n"
		<< "\tновую очередь все самолеты с заданным с клавиатуры диапазоном расхода\n"
		<< "\tгорючего. Исходная очередь не должна измениться.Можно использовать\n"
		<< "\tвспомогательную очередь – динамическую переменную.\n\n\n";

	// объект QueuePlane
	QueuePlane source(getRand(3, 5)), dest(source.getSize());

	// заполнение source
	fillQueuePlane(source, source.getSize());

	// копия source
	QueuePlane temp(source);

	// диапазон
	int min, max;

	// вывод стека 
	cout << "\n\n\t\t\t\tИсходная очередь до изменения\n\n"
		<< source << "\n\n\n"

	// ввод диапазона дальности и включение курсора
	<< "\tВведите диапазон дальности полёта самолёта(минимум - максимум): " << cursor_on;
	cin >> min >> max;

	// вылключение курсора
	setCursorVisible(false);

	// если минимум больше максимума
	if (min > max)
		throw exception("Минимальный диапазон должен быть меньше или равен максимальному!");

	// перемещение 
	task4Insert(temp, dest, min, max);

	// вывод стека 
	cout << "\n\n\t\t\t\tИсходная очередь после изменения\n\n"
		<< source << "\n\n\n"
		<< "\n\n\t\t\t\tРезультирующая очередь\n\n"
		<< dest << "\n\n\n"
		<< "\tВведённый диапазон(минимум - максимум): " << min << " - " << max << "\n\n";

	getKey();
}

// перемещение элементов по диапазону дальности полёта
void App::task4Insert(QueuePlane& source, QueuePlane& dest, int min, int max)
{
	while (!source.isEmpty() && !dest.isFull())
	{
		// текущий элемент
		Plane tmpPlane = source.dequeue();

		// текущая дальность полёта
		int tmpDist = tmpPlane.getDistance();

		// если дальность полёта текущего самолёта входит в диапазон
		if (tmpDist >= min && tmpDist <= max)
			dest.enqueue(tmpPlane);
	}
}

#pragma endregion

#pragma endregion

#pragma region Общие методы

// заполнение очереди (double), n - количество заполняемых элементов
void App::fillQueueDbl(QueueDbl& queueDbl, int n)
{
	for (int i = 0; i < n; i++)
	{
		// заполнение случайным элементом
		queueDbl.enqueue(getRand(-40., 99.));
	}
}

// заполнение очереди (Plane), n - количество заполняемых элементов
void App::fillQueuePlane(QueuePlane& queuePlane, int n)
{
	for (size_t i = 0; i < n && !queuePlane.isFull(); i++)
	{
		queuePlane.enqueue(genPlane());
	}
}

// генерация самолёта 
Plane App::genPlane()
{
	// размер массива шаблонов
	const int size = 5;

	// массив самолётов шаблонов
	Plane planes[size]
	{
		Plane("Airbus А380", 525, 345, 12000, 275'000'000, 15000, "F - WWOW"),
		Plane("Boeing 747", 452, 400, 10700, 266'000'000, 12000, "B - 18215"),
		Plane("Boeing 777", 550, 500, 13500, 280'000'000, 13000, "G - YMMM"),
		Plane("Airbus A320", 150, 115, 2100, 93'900'000, 10000, "F - GFKC"),
		Plane("Airbus A318", 132, 86, 2150, 65'000'000, 11000, "D - APWG"),
	};

	// копирование случайного элемента из массива шаблонов
	Plane newPlane = planes[getRand(0, size - 1)];

	// генерация данных
	
	// количество пассажиров
	int tmp = newPlane.getSeat();
	newPlane.setCount_passengers(getRand(0, tmp));

	// дистанция полёта
	tmp = newPlane.getDistance();
	newPlane.setDistance(getRand(tmp - 1000, tmp + 1000));

	// цена
	tmp = newPlane.getPrice();
	newPlane.setPrice(getRand(tmp - 10'000'000, tmp + 10'000'000));

	// новый номер
	char newNumber[Plane::NUMBER_SIZE + 1];

	// длина номера самолёта
	int len = strlen(newPlane.getNumber());

	strncpy(newNumber, newPlane.getNumber(), len);

	for (size_t i = 0; i < len; i++)
	{
		// текущий символ
		char ch = newNumber[i];

		// если текущий символ является цифрой 
		if (ch >= '0' && ch <= '9')
			ch = getRand('0', '9');

		// если текущий символ является буквой
		else if (ch >= 'A' && ch <= 'Z')
			ch = getRand('A', 'Z');

		newNumber[i] = ch;
	}

	newNumber[len] = 0;

	newPlane.setNumber(newNumber);

	return newPlane;
}

#pragma endregion


