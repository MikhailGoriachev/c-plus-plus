#pragma once
#include "pch.h"
#include "Utils.h"
#include "QueueDbl.h"
#include "QueuePlane.h"
#include "Plane.h"

/*
	Разработать приложение с использованием меню для закрепления работы с очередью.
	Разработайте класс очереди QueueDbl (на основе класса Queueс кольцевым буфером,
	из классной работы) для хранения чисел типа double. Также разработайте класс
	очереди QueuePlane для хранения объектов класса Plane. Используйте динамический
	массив для контейнера данных, размер массива задается в конструкторе и не
	меняется во время работы.
	•	Задача 1. Даны две непустые очереди вещественных (double) чисел, заполненные
		случайными значениями. Переместить все элементы из первой очереди во вторую
		(в результате элементы первой очереди будут располагаться во второй очереди
		в исходном порядке).
	•	Задача 2. Даны две непустые очереди вещественных (double) чисел, заполненные
		случайными значениями. Перемещать элементы из первой очереди во вторую, пока
		значение первого элемента первой очереди не станет отрицательным
		(перемещенные элементы первой очереди будут располагаться во второй очереди
		в исходном порядке). Если в первой очереди нет элементов с отрицательными
		значениями, то переместить из первой очереди во вторую все элементы.
	•	Задача 3. Дана непустая очередь вещественных (double) чисел, заполненная
		случайными значениями. Создать две новых очереди, переместив в первую из них
		все элементы исходной очереди с положительными значениями, а во вторую — с
		отрицательными (элементы в новых очередях будут располагаться в исходном
		порядке; одна из этих очередей может оказаться пустой).
	•	Задача 4. Дана непустая очередь QueuePlane. Переместить из этой очереди в
		новую очередь все самолеты с заданным с клавиатуры диапазоном расхода
		горючего. Исходная очередь не должна измениться.Можно использовать
		вспомогательную очередь – динамическую переменную.
*/

class App
{
public:

#pragma region Конструкторы, деструктор и перегрузка операции присваивания

	// конструктор по умолчанию
	App() = default;

	// копирующий конструктор 
	App(const App& app) = default;

	// деструктор 
	~App() = default;

	// перегрузка операции присваивания
	App& operator=(const App& app) = default;

#pragma endregion

#pragma region Задания 

#pragma region Задание 1

	// Задача 1. Перемещение элементов из одной очереди во вторую
	void task1();
	
	// перемещение элементов 
	void task1Insert(QueueDbl& source, QueueDbl& dest);

#pragma endregion

#pragma region Задание 2

	// Задача 2. Перемещение до отрицательного элемента
	void task2();	

	// перемещение элементов 
	void task2Insert(QueueDbl& source, QueueDbl& dest);

#pragma endregion

#pragma region Задание 3

	// Задача 3. Разделение очереди на отрицателньую и положительную
	void task3();

	// перемещение элементов в две очереди: отрицательную и положительную
	void task3Insert(QueueDbl& source, QueueDbl& neg, QueueDbl& pos);

#pragma endregion

#pragma region Задание 4
	// Задача 4. Перемещение самолётов по диапазону расхода горючего
	void task4();

	// перемещение элементов по диапазону дальности полёта
	void task4Insert(QueuePlane& source, QueuePlane& dest, int min, int max);

#pragma endregion

#pragma endregion

#pragma region Методы

	// заполнение очереди (double), n - количество заполняемых элементов
	void fillQueueDbl(QueueDbl& queueDbl, int n);

	// заполнение очереди (Plane), n - количество заполняемых элементов
	void fillQueuePlane(QueuePlane& queuePlane, int n);

	// генерация самолёта 
	Plane genPlane();

#pragma endregion
};

