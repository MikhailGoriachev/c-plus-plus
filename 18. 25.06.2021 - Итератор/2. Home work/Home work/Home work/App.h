#pragma once
#include "pch.h"
#include "Utils.h"

#include "MenuItem.h"
#include "menu.h"

#include "DblList.h"
#include "Stack.h"
#include "Queue.h"
#include "Person.h"
/*
		Задача 1.
	Разработайте двунаправленный итератор для двухсвязного списка – шаблонного класса
	DblList из предыдущего задания. Продемонстрируйте работу итератора, на экземпляре
	двусвязного списка, закрытого типом int.
	Операции итератора:
	•	begin()переход итератора на начало контейнера, возвращает 0
	•	end()переход итератора в конец контейнера, возвращает позицию, следующую за
		последней доступной позицией
	•	*разыменование итератора, возвращает ссылку на значение, хранимое в элементе,
		на который указывает итератор
	•	++ только префиксный инкремент, переход к следующему элементу контейнера
	•	-- только префиксный декремент, переход к предыдущему элементу контейнера
	•	T get() получение значения, хранимого в элементе, на который указывает итератор,
		доступ по чтению
	•	void put(T value) запись нового значения в элемент контейнера, на который
		указывает итератор, доступ по записи

		Задача 2.
	С использованием шаблонного класса стека с итератором проверить правильность
	расстановки скобок в строке символов.
	Cтроки считывать из текстового файла, длина строки не превышает 80 символов
	(не обрабатывать слишком длинные строки).В файле не менее 3х строк.
	Виды скобок: () [] {}
	Пример строк:
	( тут ( может { быть [](произвольный) текст { например }[ такой]})) - правильно
	расставлены скобки
	({)[()]} – неправильно расставлены скобки
	Выводить результаты в консоль – строка для обработки, ниже – строка с точками,
	соответствующими символам, место обнаружения первой ошибки обозначать символом ^.

		Задача 3.
	С использованием шаблонного класса очереди с итератором реализовать очередь
	нуждающихся в улучшении жилищных условий. Заполняйте очереди из массивов, на
	менее 10 элементов в массиве.
	Элемент очереди должен хранить фамилию, имя и отчество претендента, количество
	членов семьи, площадь квартиры в м2, количество комнат, дату постановки на учет
	(день, месяц, год–класс Date). Очередь имеет название, хранит имя бинарного файла
	для данных.
	Реализовать дополнительно операции (при помощи итераторов):
	•	Поиск в очереди по фамилии – находим первую подходящую фамилию, остальных
		однофамильцев игнорировать
	•	Объединение двух очередей в новую очередь. Очередников, находящихся в обеих
		очередях включать в итоговую очередь только один раз.Имя результирующей очереди
		должно быть:Объединение “очередь1” и “очередь2”.
*/

// структура для второго задания содержащая индекс скобки и символ скобки
struct BracketPosition
{
	// символ скобки
	char bracket;

	// позиция
	int position;
};

// TODO: прикладная часть - полезная работа приложения - бизнес-логика приложения
class App
{
	// DblList для проверки итератора. Задание 1.
	DblList<int> list_;

	// очередь нуждающихся в улучшении жилищных условий. Задание 3.
	Queue<Person> queueOne;
	Queue<Person> queueTwo;
	Queue<Person> queueResult;

public:

#pragma region ТЕСТОВЫЕ ФУНКЦИИ 

	// Задача 1. Итератор
	void task1();

	// вывод списка через итератор
	void printListIterator(DblList<int>::Iterator<int> iterator);

	// Задача 2. Проверка строки на корректность
	void task2();

	// открытие файла и считавание содержимого в массив
	void scanFile(FILE* file);

	// анализация строки по условию задания
	int searchErrorStr(char* buffer, int sizeStr);

	// индекс найденного символа в строке
	int strChrIndex(char* str, char value);

	// вывод строки в цвете с подсветкой ошибок
	void printStrColor(char* str, int errorPosition, int numberStr);

	// Задача 3. Очередь нуждающихся в улучшении жилищных условий
	void task3();

	// случайная фамилия из результирующей очереди
	char* getSurname(Queue<Person>::Iterator<Person> iteratorRes);

	// поиск в очереди по фамилии
	Person search(Queue<Person>::Iterator<Person> iteratorOne, char* surname);

	// вывод очереди
	void printQueue(Queue<Person>::Iterator<Person> iterator);

	// перемещение дух очередей в одну через итератор
	void insertQueue(Queue<Person>& queueOne, Queue<Person>& queueTwo, Queue<Person>& queueResult);

	// проверка на наличие Person по ФИО в очереди
	// true - элемент найден
	// false - элемент НЕ найден
	bool checkQueue(Queue<Person>& queue, Person& person);

#pragma endregion

};

