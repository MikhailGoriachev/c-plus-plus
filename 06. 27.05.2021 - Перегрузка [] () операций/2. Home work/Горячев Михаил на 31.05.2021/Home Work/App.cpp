#include "App.h"
#include "pch.h"
#include "Conoid.h"
#include "Utils.h"
#include "ArrayConoid.h"
#include "func.h"
#include "Matrix.h"

#pragma region Задание 1

/*
*	Задача 1. Создайте класс, описывающий усеченный конусConoid (радиус верхнего основания, радиус
*	нижнего основания, высота – тип полей double). Реализуйтеконструкторы (только два: по умолчанию и
*	инициирующий – т.е. задающий все поля класса), геттеры и сеттеры (при некорректных значениях
*	выбрасывать в сеттерах исключение exception), методы для вычисления площади и объема усеченного конуса.
*	Перегрузите операции:
*	•	++ префиксный и постфиксный инкременты – увеличение на 1 высоты и радиусов оснований, перегрузка
*	методомкласса
*	•	-- префиксный и постфиксный декременты – уменьшение на 1 высоты и радиусов оснований, перегрузка
*	дружественной функцией класса, выбрасывать исключение при нулевом или отрицательном результате
*	•	<<операция вывода, выводить радиусы и высоту, площадь поверхности и объем в виде строки таблицы
*	Создайте классArrayConoid, хранящий динамический массив из усеченных конусов – объектов класса Conoid
*	и размер этого массива. Массив создавать в конструкторах, требуется только два конструктора: по умолчанию,
*	создающий массив из 3 элементов, конструктор с параметром – количеством создаваемых элементов). Также
*	разработайте деструктор для освобождения памяти, занятой массивом усеченных конусов.
*	Геттеры и сеттеры в классе ArrayConoid не разрабатывайте, реализуйте только константный метод size(),
*	возвращающий размер массива.
*	В классе ArrayConoidперегрузите операции:
*	•	индексирования [], при выходе индекса за допустимые пределы выбрасывайте исключения
*	•	<<вывода массива в виде таблицы (элементы массива выводитьперегруженной операцией вывода)
*	Реализуйте методы класса ArrayConoid:
*	•	поиск индекса первого элемента массива с минимальным объемом
*	•	поиск индекса элемента массива с максимальной площадью.
*	С использованием перегруженной операции класса ArrayConoid[]реализуйте функции (передавайте в функции
*	объект класса ArrayConoid по ссылке):
*	•	вычисления суммарного объема конусов
*	•	вычисления суммарной площади поверхности конусов
*	•	вывод массива в консоль с выделением цветом конуса/конусов с максимальной площадью.
*	Создайте объект (экземпляр) класса ArrayConoid, продемонстрируйте разработанные методы.
*
*/

#pragma region Методы Задания 1
// нахождение индекса конуса с максимальной площадью конуса
int maximumIndex(ArrayConoid& conoids)
{
	int max = 0;

	for (size_t i = 1; i < conoids.size(); i++)
	{
		if (conoids[max].MathS() < conoids[i].MathS())
		{
			max = i;
		}
	}

	return max;
}

// сумма объёма
double App::summV(Conoid* conoid, size_t size)
{
	double summ = 0.0;

	for (Conoid* conoid_p = conoid; conoid_p < conoid + size; conoid_p++)
	{
		summ += conoid->MathV();
	}

	return summ;
}

// сумма площади
double App::summS(Conoid* conoid, size_t size)
{
	double summ = 0.0;

	for (Conoid* conoid_p = conoid; conoid_p < conoid + size; conoid_p++)
	{
		summ += conoid->MathS();
	}

	return summ;
}

// вывод массива цилиндров в табличном формате, горизонтальная линия: — Alt+0151
ostream& operator<<(ostream& os, ArrayConoid& arr)
{
	setColor(headerColor);

	os  << "\t    +—————+—————————————————+————————————————+————————————————+————————————————+————————————————+\n"
		<< "\t    |  N  |    Радиус, R    |    Радиус, r   |    Высота, H   |   Площадь, S   |    Объем, V    |\n"
		<< "\t    +—————+—————————————————+————————————————+————————————————+————————————————+————————————————+\n";

	setColor(mainColor);

	size_t maxIndex = maximumIndex(arr);

	// выводим строки таблицы цилиндров, с выделением цветом
	// строки с минимальным объемом, перед и после этой строки
	// выводим цветовые "хвостики"
	for (size_t i = 0; i < arr.size_; ++i) {
		cout << "\t";
		setColor(arr[i].MathS() == arr[maxIndex].MathS() ? acctColor : mainColor);

		//setColor(headerColor);

		cout << "    " << "| " << setw(3) << i + 1;

		//setColor(mainColor);

		// перегрузка вывода
		cout << arr[i];

		cout << "    ";
		setColor(mainColor);
		cout << "\n";
	} // for i

	setColor(headerColor);

	cout << "\t    +—————+—————————————————+————————————————+————————————————+————————————————+————————————————+\n";

	setColor(mainColor);

	return os;

} // showTable

// дружественная функция класса Conoid. перегрузка операции вывода << 
ostream& operator<<(ostream& link, Conoid& con)
{
	link << " | " << setw(15) << con.radius1_
		<< " | " << setw(14) << con.radius2_
		<< " | " << setw(14) << con.height_
		<< " | " << setw(14) << con.MathS()
		<< " | " << setw(14) << con.MathV()
		<< " |";

	return link;
}

// дружественная функция класса Conoid. перегрузка операции ввода >> 
/*istream& operator>>(istream& link, Conoid& con)
{
	link >> con.height_ >> con.radius1_ >> con.radius2_;

	// если высота меньше или равна нулю
	if (con.height_ <= 0)
	{
		throw exception("Введённая высота должна быть больше нуля!");
	}

	// если радиус основания меньше радиуса вершины
	if (con.radius1_ < con.radius2_)
	{
		throw exception("Радиус основания должен быть больше радиуса вершины!");
	}

	return link;
}*/

#pragma endregion

#pragma region Задание 1 (тело)
// Задание 1
void App::task1()
{
	setColor(mainColor);

	cls();

	setColor(headerColor);

#pragma region Вывод задания
	cout << "\n\n\t\t\t\tЗадание 1\n\n";

	cout << "\t\tСоздайте класс, описывающий усеченный конус Conoid (радиус \n"
		<< "\t\tверхнего основания, радиус нижнего основания, высота – тип полей double).  \n"
		<< "\t\tРеализуйте конструкторы (только два: по умолчанию и инициирующий – т.е. \n"
		<< "\t\tзадающий все поля класса), геттеры и сеттеры (при некорректных значениях \n"
		<< "\t\tвыбрасывать в сеттерах исключение exception), методы для вычисления площади \n"
		<< "\t\tи объема усеченного конуса.\n\n"
		<< "\t\tПерегрузите операции:\n"
		<< "\t\tвывода данных усеченного конуса (радиусы и высота, площадь поверхности\n"
		<< "\t\tи объем) в виде строки таблицы. \n\n"
		<< "\t\tПерегрузите операции методами класса:\n\n"
		<< "\t\t\t•	++ префиксный и постфиксный инкременты – увеличение на 1 высоты и \n"
		<< "\t\t\t\tрадиусов оснований, перегрузка методом класса\n\n"
		<< "\t\t\t•	-- префиксный и постфиксный декременты – уменьшение на 1 высоты и \n"
		<< "\t\t\t\tрадиусов оснований, перегрузка дружественной функцией класса, \n"
		<< "\t\t\t\tвыбрасывать исключение при нулевом или отрицательном результате\n\n"
		<< "\t\t\t•	<< операция вывода, выводить радиусы и высоту, площадь поверхности и \n"
		<< "\t\t\t\tобъем в виде строки таблицы \n\n"
		<< "\t\t\tСоздайте класс \n\n"
		<< "\t\t\tArrayConoid, хранящий динамический массив из усеченных конусов – объектов \n"
		<< "\t\t\tкласса Conoid и размер этого массива. Массив создавать в конструкторах, \n"
		<< "\t\t\tтребуется только два конструктора: по умолчанию, создающий массив из 3 \n"
		<< "\t\t\tэлементов, конструктор с параметром – количеством создаваемых элементов). \n"
		<< "\t\t\tТакже разработайте деструктор для освобождения памяти, занятой массивом \n"
		<< "\t\t\tусеченных конусов.\n\n"
		<< "\t\t\tГеттеры и сеттеры в классе ArrayConoid не разрабатывайте, реализуйте только \n"
		<< "\t\t\tконстантный метод size(), возвращающий размер массива.\n\n"
		<< "\t\t\tВ классе ArrayConoidперегрузите операции:\n\n"
		<< "\t\t\t•	индексирования [], при выходе индекса за допустимые пределы \n"
		<< "\t\t\t\tвыбрасывайте исключения\n\n"
		<< "\t\t\t•	<< вывода массива в виде таблицы (элементы массива выводить \n\n"
		<< "\t\t\t\tперегруженной операцией вывода)\n\n"
		<< "\t\t\tРеализуйте методы класса ArrayConoid:\n\n"
		<< "\t\t\t•	поиск индекса первого элемента массива с минимальным объемом\n\n"
		<< "\t\t\t•	поиск индекса элемента массива с максимальной площадью. \n\n"
		<< "\t\t\tС использованием перегруженной операции класса ArrayConoid[] реализуйте \n"
		<< "\t\t\tфункции (передавайте в функции объект класса ArrayConoid по ссылке):\n\n"
		<< "\t\t\t•	вычисления суммарного объема конусов\n\n"
		<< "\t\t\t•	вычисления суммарной площади поверхности конусов\n\n"
		<< "\t\t\t•	вывод массива в консоль с выделением цветом конуса/конусов с \n"
		<< "\t\t\t\tмаксимальной площадью.\n\n"
		<< "\t\t\tСоздайте объект (экземпляр) класса ArrayConoid, продемонстрируйте \n"
		<< "\t\t\tразработанные методы.\n\n";

	setColor(headerColor);

	getKey();

	cls();

#pragma endregion

	// количество цилиндров
	int size;

	setCursorVisible(true);

	// ввод количества создаваемых усеченных конусов
	cout << "\n\n\t\tВведите колчество усеченных конусов: ";

	cin >> size;

	if (size < 1)
	{
		// сообщение exception на тот случай, если будут введены неправильные данные
		throw exception("Количество усеченных конусов должно быть больше нуля!");
	}

	// отчистка экрана
	cls();
	
	// объект класса ArrayConoid
	ArrayConoid arr = ArrayConoid(size);

	// заполнение конусов случайными данными
	generConoid(arr);

	// выключение курсора
	setCursorVisible(false);

	// символ для ввода
	char n;

	// переменные для операций с цилиндрами
	int a;

	size_t indexMin;
	size_t indexMax;
	size_t index;

	// хранение текущего цвета
	short cl;

	while (true)
	{
		cls();

		// вывод таблицы
		cout << arr;

		setColor(headerColor);

		cout << setw(38) << " | " << setw(41) << right << "Суммарная площадь: " << allSummS(arr) << " |" << endl;

		cout << setw(38) << " | " << setw(41) << right << "Суммарный объём: " << allSummV(arr) << " |" << endl;


		cout << "\n\n\n\n\t\t1. Инкременты префиксный и постфиксный" << endl;
		cout << "\n\n\n\n\t\t2. Декременты префиксный и постфиксный" << endl;
		cout << "\n\n\n\n\t\t3. Поиск первого элемента с минимальным объёмом" << endl;
		cout << "\n\n\n\n\t\t4. Поиск первого элемента с максимальнй площадью" << endl;
		cout << "\n\n\n\n\n\n\t\tESC ВЫХОД" << endl;
		
		cout << "\n\n\n\t\tВыберите пункт...";

		// проверка ввода 
		while (true)
		{
			n = getKey("");

			// если значение n входит в один из пунктов
			if (n < '5' && n > '0')
			{
				// включение курсора
				setCursorVisible(true);

				cls();

				// вывод таблицы
				cout << arr;

				setColor(headerColor);

				cout << setw(38) << " | " << setw(41) << right << "Суммарная площадь: " << allSummS(arr) << " |" << endl;

				cout << setw(38) << " | " << setw(41) << right << "Суммарный объём: " << allSummV(arr) << " |" << endl;

				switch (n)
				{

					// 1. Инкременты префиксный и постфиксный
				case '1':

					cout << "\n\n\t\t\t\t\t\tИнкременты префиксный и постфиксный\n\n" << endl;

					cout << "\tВыберите конус: ";
					cin >> a;

					index = a - 1;

					cout << "\n\n\t\t\t\t\tКонус " << a << endl << endl;

					cout << "\t\t\t";

					cputs("Инкремент префиксный\n", resColor);

					cout << "\n\n\t\t\t\t\tВозвращаемое значение" << endl;
					cout << "\t\t" << ++arr[index];

					cout << endl << endl;

					cout << "\n\n\t\t\t\t\tИзмененный конус" << endl;
					cout << "\t\t" << arr[index];

					cout << endl << endl;

					cout << "\t\t\t";

					cputs ("Инкремент постфиксный\n", resColor);

					cout << "\n\n\t\t\t\t\tВозвращаемое значение" << endl;
					cout << "\t\t" << arr[index]++;

					cout << endl << endl;

					cout << "\n\n\t\t\t\t\tИзмененный конус" << endl;
					cout << "\t\t" << arr[index];

					cout << endl << endl;

					getKey();

					break;

					// 2. Декременты префиксный и постфиксный
				case '2':
					cout << "\n\n\t\t\t\t\t\tДекременты префиксный и постфиксный\n\n" << endl;

					cout << "\tВыберите конус: ";
					cin >> a;

					index = a - 1;

					cout << "\n\n\t\t\t\t\tКонус " << a << endl << endl;

					cout << "\t\t\t";

					cputs("Декремент префиксный\n", resColor);

					cout << "\n\n\t\t\t\t\tВозвращаемое значение" << endl;
					cout << "\t\t" << --arr[index];

					cout << endl << endl;

					cout << "\n\n\t\t\t\t\tИзмененный конус" << endl;
					cout << "\t\t" << arr[index];

					cout << endl << endl;

					cout << "\n\t\t\t";

					cputs("Декремент постфиксный\n", resColor);

					cout << "\n\n\t\t\t\t\tВозвращаемое значение" << endl;
					cout << "\t\t" << arr[index]--;

					cout << endl << endl;

					cout << "\n\n\t\t\t\t\tИзмененный конус" << endl;
					cout << "\t\t" << arr[index];

					cout << endl << endl;

					getKey();

					break;

					// 3. Поиск первого элемента с минимальным объёмом
				case '3':

					cout << "\n\n\t\t\t\t\t\tПоиск первого элемента с минимальным объёмом\n\n" << endl;

					// индекс минимального элемента
					indexMin = arr.MinimumV();

					cl = getColor();

					cout << "\t\t\t";

					setColor(resColor);

					cout << "Элемент с минимальным объёмом - Conoid[ " << indexMin << " ]" << endl << endl;

					setColor(cl);

					cout << "\t\t" << arr[indexMin];

					cout << "\n\n\n";

					getKey();

					break;

				case '4':

					cout << "\n\n\t\t\t\t\t\tПоиск первого элемента с максимальнй площадью\n\n" << endl;

					// индекс минимального элемента
					indexMax = arr.MaximumS();

					cout << "\t\t\t";

					cl = getColor();

					setColor(resColor);

					cout << "Элемент с максимальной площадью - Conoid[ " << indexMax << " ]\n\n";

					setColor(cl);

					cout << "\t\t" << arr[indexMax];

					cout << "\n\n\n";

					getKey();

					break;

				default:
					break;
				}
				break;
			}

			if (n == 27)
			{
				return;
			}
		}
	}
}

#pragma endregion

#pragma endregion

#pragma region Задание 2 

/*
*
* Задача 2. В том же консольном приложении, с использованием класса Matrix из приложения,
* рассмотренного в классной работе, решите задачу. Разработайте функции, в которые по ссылке
* передавайте объект класса Matrix.
* •	Заполните объект класса Matrixиз 5 строк и 8 столбцов случайными числами
* •	Найдите сумму элементов в тех столбцах, которые не содержат отрицательных элементов
* •	Найдите количество столбцов, содержащих хотя бы один нулевой элемент
*
*/

#pragma region Методы Задания 2

// заполенение матрицы случайными числами (поля int)
void fillMatrix(Matrix& mtx)
{
	for (size_t i = 0; i < mtx.rows(); i++)
	{
		for (size_t k = 0; k < mtx.cols(); k++)
		{
			mtx(i, k) = getRand(-2, +10);
		}
	}
}

// сумма элементов столбца, в котором нет отрицательных элементов
int sumElem(Matrix& mtx)
{
	// сумма элементов 
	int sum = 0;

	// сумма столбца
	int sumTmp = 0;
	for (int i = 0; i < mtx.cols(); i++)
	{
		for (int k = 0; k < mtx.rows(); k++)
		{
			// если число является положительным
			if (mtx(k, i) >= 0)
			{
				sumTmp += mtx(k, i);
			} 
			else
			{
				sumTmp = 0;
				break;
			}
		}

		sum += sumTmp;

		sumTmp = 0;
	}

	return sum;
}

// поиск количества строк содержащих элемент со значением 0
int countRowsNull(Matrix& mtx)
{
	// количество строк в которых входит элемент со значением 0
	int count = 0;

	for (size_t i = 0; i < mtx.rows(); i++)
	{
		for (size_t k = 0; k < mtx.cols(); k++)
		{
			if (mtx(i, k) == 0)
			{
				count++;

				break;
			}
		}
	}

	return count;
}

#pragma endregion

#pragma region Задание 2 (тело)

void App::task2() 
{

#pragma region Вывод задания
	setColor(mainColor);

	cls();

	setColor(headerColor);

	cout << "\n\n\t\t\t\tЗадание 2\n\n";

	cout << "\t\tЗадача 2. В том же консольном приложении, с использованием класса\n"
		<< "\t\tMatrix из приложения, рассмотренного в классной работе, решите задачу.\n"
		<< "\t\tРазработайте функции, в которые по ссылке передавайте объект класса Matrix.\n\n"
		<< "\t\t•	Заполните объект класса Matrixиз 5 строк и 8 столбцов случайными числами\n\n"
		<< "\t\t•	Найдите сумму элементов в тех столбцах, которые не содержат отрицательных элементов\n\n"
		<< "\t\t•	Найдите количество столбцов, содержащих хотя бы один нулевой элемент\n\n";

	setColor(headerColor);

	getKey();

	cls();

#pragma endregion

	// матрица
	Matrix* P_mtx = new Matrix();

	// ссылка на матрицу
	Matrix& mtx = *P_mtx;

	fillMatrix(mtx);

	// вывод матрицы
	cout << "\t\t\t\t\t\t\tМатрица\n\n" << endl;

	for (size_t i = 0; i < mtx.rows(); i++)
	{
		cout << "\t\t+";
		for (size_t i = 0; i < mtx.cols(); i++)
		{
			cout << "—————————+";
		}

		cout << "\n\t\t";

		for (size_t k = 0; k < mtx.cols(); k++)
		{
			cout << "| " << setw(8) << mtx(i, k);

			// если это последний элемент то будет выведена линия
			if (k == mtx.cols() - 1)
			{
				cout << "|" << endl;
			}


		}
	}

	cout << "\t\t+";
	for (size_t i = 0; i < mtx.cols(); i++)
	{
		cout << "—————————+";
	}

	cout << "\n\n\n\n\t\tСумма элементов в тех столбцах, которые не содержат отрицательных элементов: " << sumElem(mtx) << endl;
	cout << "\n\t\tКоличество столбцов, содержащих хотя бы один нулевой элемент: " << countRowsNull(mtx) << "\n\n";

	getKey();

	return;
}

#pragma endregion

#pragma endregion
