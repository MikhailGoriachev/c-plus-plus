// Шаблон консольного приложения для начала курса "ООП на C++"
//

#include "App.h"
#include "pch.h"
#include "Utils.h"

#include "menu.h"
#include "MenuItem.h"

#include "Palette.h"
#include "StackDbl.h"


/*
	Разработать приложение с использованием меню для закрепления работы со стеком, очередью.
	Для решения задач разработайте классы StackDblдля хранения данных типа double в динамическом
	массиве (размер массива задается в конструкторе и в дальнейшем не меняется, размер по
	умолчанию – 12 элементов), StackPlane для хранения данных типа Plane (класс из предыдущего
	задания, стек на базе статического массива, размер 10 элементов).Стеки StackDbl, StackPlane
	реализуйте на основе класса Stackиз классной работы.
	Задача 1.	Даны два непустых стека вещественных (double) чисел. Переместить все элементы из
		первого стека во второй (в результате элементы первого стека будут располагаться во втором
		стеке в порядке, обратном исходному). Если в первом стеке слишком много элементов, выполняйте
		перемещение до заполнения второго стека.
	Задача 2.	Даны два непустых стека вещественных (double) чисел. Перемещать элементы из первого
		стека во второй, пока значение вершины первого стека не станет отрицательным (перемещенные элементы
		первого стека будут располагаться во втором стеке в порядке, обратном исходному). Если в первом
		стеке нет отрицательных элементов, то переместить из первого стека во второй все элементы. Если в первом стеке слишком много элементов, выполняйте перемещение до заполнения второго стека.
	Задача 3.	Дан непустой стек вещественных (double) чисел. Создать два новых стека, переместив
		в первый из них все элементы исходного стека с положительными значениями, а во второй — с
		отрицательными (элементы в новых стеках будут располагаться в порядке, обратном исходному; один
		из этих стеков может оказаться пустым).
	Задача 4.	Дан непустой стек StackPlane. Переместить данные до самолета с заданным с клавиатуры
		регистрационным номером в новый стек типа StackPlane.
	Задача 5.	Усложненное. Дан непустой стек StackPlane.Переместить из этого стека в новый стек все
		самолеты с заданным с клавиатуры диапазоном дальности полета. Исходный стек не должен измениться.
		Можно использовать вспомогательный стек – динамическую переменную.
*/


// инициализация статических констант класса Plane
double const Plane::MAX_FUEL = 20000.;
double const Plane::MIN_FUEL = 0.1;

int main()
{
    init(L"Домашнее задание на 14.06.2021");

	// для вывода в строку средствами C++
	ostringstream oss;

	// TODO: Ваше приложение
	App app;
	
	// константы для swith меню
	enum Commands {
		// Задание 1
		CMD_TASK_ONE,
		// Задание 2
		CMD_TASK_TWO,
		// Задание 3
		CMD_TASK_THREE,
		// Задание 4
		CMD_TASK_FOURE,
		// Задание 5
		CMD_TASK_FIVE
	};

	// количество пунктов меню
	const int N_MENU = 6;

	MenuItem items[N_MENU] = {
		MenuItem("Задание 1", CMD_TASK_ONE),
		MenuItem("Задание 2", CMD_TASK_TWO),
		MenuItem("Задание 3", CMD_TASK_THREE),
		MenuItem("Задание 4", CMD_TASK_FOURE),
		MenuItem("Задание 5", CMD_TASK_FIVE),

		// выход из программы
		MenuItem("Выход",  Menu::CMD_QUIT)
	};

	// количество цветов 
	const int N_PALETTE = 5;

	// массив цветов
	short palette[N_PALETTE] = { WHITE_ON_BLACK, LTCYAN_ON_BLACK, BLACK_ON_LTCYAN, GRAY_ON_BLACK };

	// объект меню
	Menu mainMenu("Главное меню приложения", items, N_MENU, palette, COORD{ 5, 5 });
	
	while (true)
	{
		try {
			cout << color(palette[Menu::PAL_CONSOLE]) << cls;
			int cmd = mainMenu.Navigate();
			cout << color(palette[Menu::PAL_CONSOLE]) << cls;
			if (cmd == Menu::CMD_QUIT) return 0;

			switch (cmd)
			{
				// Задание 1
			case CMD_TASK_ONE:
				app.task1();
				break;
				// Задание 2
			case CMD_TASK_TWO:
				app.task2();
				break;
				// Задание 3
			case CMD_TASK_THREE:
				app.task3();
				break;
				// Задание 4
			case CMD_TASK_FOURE:
				app.task4();
				break;
				// Задание 5
			case CMD_TASK_FIVE:
				app.task5();
				break;
			}
		}
		catch (exception& ex) {
			oss.str("");  // очистка строки - буфера вывода
			oss << "\n\t" << ex.what() << "\n";

			// вывод строки с сообщением об ошибке в цвете
			cputs(oss.str().c_str(), errColor);

			getKey();

			// что на самом деле происходит
			// string temp = oss.str();
			// cputs(temp.c_str(), errColor);
		} // try-catch
	}
} // main
