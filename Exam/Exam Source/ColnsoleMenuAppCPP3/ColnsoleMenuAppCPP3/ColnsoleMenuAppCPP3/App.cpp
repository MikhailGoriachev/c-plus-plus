#include "App.h"

#include "menu.h"
#include "MenuItem.h"

#pragma region Превью запуска приложения 

// Превью запуска приложения
void App::preview()
{
	// заполенение фона 
	fillBackground(35, 121, BLACK_ON_CYAN, 20);

	// вывод рамки
	outFrame(10, 50, 35, 10, BLACK_ON_LTCYAN, BLACK_ON_CYAN);

	// вывод текста 
	outText("Экзаменационная работа Горячева Михаила", 30, BLACK_ON_CYAN, 40, 13);
	outText("ООП C++", 30, BLACK_ON_CYAN, 57, 15);

	// вывод полосы загрузки 
	loadingLine(61, 4000, 30, 30);

	cout << "\n";

	Sleep(500);
}

// заполнение заднего фона 
void App::fillBackground(int row, int col, short color, int time)
{
	// текущий цвет 
	short cl = getColor();
	
	// включение заданного цвета 
	setColor(color);

	ostringstream os;

	os << setw(col) << " ";

	string str = os.str();

	// заполнение 
	for (int i = 0; i < row; i++)
	{
		cout << pos(0, i) << str;
		Sleep(time);
	}

	// переключение цвета на исходный 
	setColor(cl);
}

// анимация вывода текста 
void App::outText(string message, int time, short color = mainColor, int x = -1, int y = -1)
{
	// установка позиции курсора, если параметры переданы
	if (x != -1 and y != -1)
	{
		// установка курсора 
		cout << pos(x, y);
	}

	// если параметры некорректны
	if (x < -1 and y < -1)
	{
		throw exception(("App: Параметры"s + "x - " + to_string(x) + "y - " + to_string(y) + " некорректны").c_str());
	}

	// текущий цвет
	short cl = getColor();

	// установка цвета 
	setColor(color);

	// длина строки
	size_t size = message.size();

	// вывод строки
	for (size_t i = 0; i < size; i++)
	{
		cout << message[i];
		Sleep(time);
	}
}

// анимация полосы загрузки 
void App::loadingLine(int size, int time, int x, int y, short colorLoading, short colorBackground, short colorComplete)
{

#pragma region Установка позиции и проверка исключений 

	// если переданны некорректные параметры
	if (size < 10 and time <= 0)
		throw exception("App: Переданы некорректные параметры в анимацию полосы загрузки");

	// если параметры некорректны
	if (x < 10 and y < 1)
	{
		throw exception(("App: Параметры"s + "x - " + to_string(x) + "y - " + to_string(y) + " некорректны").c_str());
	}

	// цвет по умолчанию 
	short cl = getColor();

	// установка курсора 
	// cout << pos(x + (size / 2) - 7, y - 3) << color(colorLoading) << setw(18) << " "
	// 	<< pos(x + (size / 2) - 7, y - 2) << " Загрузка ";

	// позиция начала вывода процентов 
	int posX = size / 2 - 8 + x;

	cout << pos(posX, y - 3) << color(BLACK_ON_BLACK) << setw(19) << left << " a" << color(colorLoading)
		<< pos(posX, y - 2) << " Загрузка " << right;

#pragma endregion 

#pragma region Переменные для вывода 

	// количество ячеек 
	int countPercent = (size / 100 > 0 ? size / 100 : size % 100 / 10);

	// длина ячейки
	int sizePercent = size / countPercent;

	// время на одно деление процентов
	int timePercent = time / countPercent;

	// время вывода одного символа 
	int timeOne = timePercent / sizePercent;

	// остаточное время вывода 
	int timeRem = timePercent % sizePercent;

	// процентов в одной ячейке
	double percentCell = 100. / countPercent;

	// процентов на один символ
	double percentCymb = 100. / size;

	// остаток символов от целого деления 
	int sizeRem = size % countPercent;

	// позиция начала процентов 
	int xPosPercent = posX + 10; // x + (size / 2) + 2;

	// проценты 
	double percent = 0.;

#pragma endregion

#pragma region Вывод 

	// вывод полосы фона 
	cout << pos(x - 1, y - 1) << color(colorBackground) << setw(size + 2) << " " 
		<< pos(x - 1, y) << color(colorBackground) << setw(size + 2) << " " 
		<< pos(x - 1, y + 1) << color(colorBackground) << setw(size + 2) << " " << color(colorComplete);

	// возвращение в начало полосы загрузки 
	for (int i = 0; i < size; i++)	cout << "\b";


	cout.precision(2);

	// вывод заполенения 
	for (int i = 0; i < countPercent; i++)
	{
		// вывод одного деления 
		for (int k = 0; k < sizePercent; k++)
		{
			percent += percentCymb;
			cout << color(colorLoading) << pos(xPosPercent, y - 2) << setw(7) << percent << "% "
				<< color(colorComplete) << pos(x++, y) << " ";

			Sleep(timeOne);
		}

		cout << color(colorLoading) << pos(xPosPercent, y - 2) << setw(7) << percent << "% ";

		// задержка по времени
		Sleep(timeRem);
	}

	// если времени на одно деление процентов равно нулю
	if (timePercent == 0)
		Sleep(time);

	// если длина строки загрузки не делится нацело на 100
	if (sizeRem != 0)
	{
		// вывод одного деления
		for (int k = 0; k < sizeRem; k++)
		{
			percent += percentCymb;

			cout << color(colorLoading) << pos(xPosPercent, y - 2) << setw(7) << percent << "% "
				<< color(colorComplete) << pos(x++, y) << " ";
			
			Sleep(timeOne);
		}
	}

	// возвращение цвета по умолчанию
	setColor(cl);

#pragma endregion

}

// вывод рамки
void App::outFrame(int hight, int width, int x, int y, short colorFrame, short colorBackground)
{
	cout << pos(x, y++) << color(colorFrame) << setw(width) << " ";

	for (int i = 0; i < hight - 2; i++, y++)
	{
		cout << pos(x, y) << color(colorFrame) << " " 
			<< color(colorBackground) << setw(width - 2) << " " 
			<< color(colorFrame) << " ";
	}

	cout << pos(x, y) << color(colorFrame) << setw(width) << " ";
}

#pragma endregion

/*
	Итоговое задание по курсу «Объектно-ориентированное программирование с 
	использованием языка C++»
	С использованием STL разработать три приложения для решения следующих задач 
	в консольных приложениях с использованием меню.

	——————————————————————————————————————————————————————————————————————————————————————————————————————————

	Задача 1 (обязательная, максимум 8 баллов)
	В векторе, состоящем из п целых элементов, выполнить следующие операции (по 
	командам меню):
	1)	количество элементов вектора, равных 0
	2)	сумму элементов вектора, расположенных после минимального элемента
	3)	удалить элементы, встречающиеся менее двух раз
	4)	упорядочить вектор по возрастанию модулей элементов
	5)	продублировать отрицательные элементы вектора
	6)	сохранить вектор в бинарном файле при помощи потока вывода
	7)	прочитать вектор из бинарного файла при помощи потока ввода

	——————————————————————————————————————————————————————————————————————————————————————————————————————————

	Задача 2 (для претендентов на 10 баллов).
	С использованием классов и алгоритмов STL, лямбда-выражений написать приложение 
	для решения следующей задачи из практикума Павловской Т.А. и Щупака Ю.А. по ООП 
	на C++:
	Написать приложения для учета книг в библиотеке. Сведения о книгах содержат: 
	идентификатор (учетный номер единицы хранения), фамилию и инициалы автора, название 
	книги, год издания, количество экземпляров данной книги в библиотеке. Сведения о 
	библиотеке – адрес библиотеки, фамилия и инициалы директора, коллекция книг. Данные 
	о библиотеке и книгах хранить в текстовом файле в формате CSV, символ разделителя «;».
	Формат файла – в первой строке данные библиотеки, в остальных строках данные о книгах, 
	одна книга – одна строка, начальная инициализация при первом запуске приложения – не 
	менее 12 книг. С помощью меню реализовать выбор и выполнение следующих функций:
	•	Вывод данных библиотеки и коллекции книг в консоль
	•	Добавление книги, ввод данных с клавиатуры, сохранение измененной коллекции в 
		текстовый файл
	•	Удаление книг по идентификатору, сохранение измененной коллекции в текстовый файл
	•	Изменение количества книг заданного автора на вводимое с клавиатуры значение, 
		сохранение измененной коллекции в текстовый файл
	•	Отбор книг в отдельный список по заданному году издания, вывод этого списка в 
		консоль, упорядочив по году издания, не изменять исходную коллекцию книг, файл 
		данных
	•	Отбор заявок в отдельный список по автору, вывод этого списка в консоль, упорядочив 
		по автору, не изменять исходную коллекцию книг, файл данных
	•	Сортировка книг по убыванию количества книг, вывод в консоль без изменения файла 
		данных
	•	Сортировка книг по идентификатору, вывод в консоль без изменения файла данных
	•	Сортировка книг по названию, вывод в консоль без изменения файла данных
	Постарайтесь свести к минимуму использование циклов – максимально используйте алгоритмы 
	STL.

	——————————————————————————————————————————————————————————————————————————————————————————————————————————

	Задача 3 (для претендентов на 12 баллов) – вариант 1
	Класс Bill представляет собой разовый платеж за телефонный разговор. Класс должен включать 
	поля: дата и время начала разговора, дата и время окончания разговора.

	Время разговора вычисляется в минутах, неполная минута, считается за полную. Должен быть 
	реализован метод, вычисляющий сумму к оплате за разговор.
	Для представления даты и времени используйте класс DateTime с полями – день, месяц, год, 
	час, минута, секунда. Реализуйте методы вычисления разности между двумя моментами времени 
	в секундах. Перегрузите операции сравнения двух моментов времени.

	Разработайте класс – список плательщиков ListPayer. Класс содержит список плательщиков за 
	телефонные услуги, дату создания списка, номер списка.

	Один элемент списка включает: информацию о плательщике – номер телефона, фамилия и инициалы, 
	фамилия и инициалы плательщика, номер телефона, тариф за минуту разговора, скидка (в процентах), 
	коллекция записей класса Bill, дату платежа, сумму платежа.

	Реализовать для класса ListPayer:
	•	Метод добавления плательщика в список
	•	Метод удаления плательщика из списка
	•	Метод поиска плательщика по номеру телефона, найденные записи помещать в отдельную коллекцию, 
		сохранять в бинарном потоке вывода
	•	Метод поиска плательщика по фамилии и инициалам, найденные записи помещать в отдельную 
		коллекцию, сохранять в бинарном потоке вывода
	•	Метод поиска плательщиков по дате платежа, найденные записи помещать в отдельную коллекцию, 
		сохранять в бинарном потоке вывода
	•	Метод вычисления полной стоимости платежей всего списка
	Реализовать создание объектов ListPayer, операции объединения и пересечения списков.
	•	Операция объединения списка – бинарная операция, на выходе получаем список из элементов двух 
		списков, без дубликатов.
	•	Операция пересечения списка – бинарная операция, на выходе получаем список из элементов 
		имеющихся и в первом, и во втором списках, без дубликатов.
	Реализовать отбор данных из списка плательщиков:
	•	По дате платежа, сортировка по номеру телефона
	•	По номеру телефона, сортировка по номеру телефона
	Реализовать сортировку списка плательщиков:
	•	По номеру телефона
	•	По убыванию суммы к оплате
	•	По убыванию времени разговоров

	——————————————————————————————————————————————————————————————————————————————————————————————————————————

	Задача 3 (для претендентов на 12 баллов) – вариант 2
	Вы участвуете в разработке приложения для фитнес-клуба, занимающегося проведением тренировок в собственных залах под руководством тренеров или самостоятельно клиентами. Предприятие также может предоставлять свои залы в аренду для работы сторонних тренеров. Про работу предприятия с точки зрения разработки приложения известно следующее.
	Можно выделить три категории пользователей: клиенты, тренеры, администрация (технический персонал оставляем без внимания 😊). Также в фитнес-клубе есть три зала (тренажерный, зал аэробики, зал боевых искусств).
	Клиенты могут получать информацию о расписании групповых занятий, о занятости залов, тренеров индивидуальных занятий. Клиентом является любая персона, купившая абонемент. Клиент может зарегистрироваться на тренировку в группе или у тренера персонально. Если на тренировку зарегистрировалось менее 2х клиентов, тренировка отменяется, об этом извещается тренер и зарегистрировавшийся клиент.
	Тренеры сообщают свой желаемый график администрации: желаемое время занятий и наиболее подходящий зал.
	Администрация занимается приемом на работу и увольнением тренеров, продажей абонементов клиентам, составлением расписаний тренеров, организацией хозяйственной деятельности.  Также администратор может формировать определенные отчеты при помощи приложения (например, отчет по тренерам – количество тренировок каждого тренера за определенный месяц).
	Клиенты и персонал фитнес-клуба (пользователи приложения) характеризуются именем, фамилией и отчеством, номером паспорта. Персонал также характеризуется должностью (тренер, администратор, уборщик, …), окладом. Администратор только один, он контролирует нескольких тренеров.
	После составления расписания или при назначении индивидуальной тренировки администратор уведомляет тренеров, клиентов индивидуальных тренировок. Также администратор извещает об изменении расписания всех клиентов фитнес-клуба.
	Тренировка описывается местом и временем проведения, тренером, списком участников (для индивидуальной тренировки в списке только один участник).
	Для 7 клиентов, 3 тренеров и 1 администратора разработать и протестировать следующую часть приложения: назначение тренеров на две групповые и одну индивидуальную тренировки – на одно и то же время, в один и тот же день, в разные залы. При этом на одно из групповых занятий записывается только один клиент (для демонстрации отмены тренировки). Используем STL и, конечно же лямбда-выражения. Начальное заполнение данных – из фиксированного набора.

	Варианты для выполнения задания
	Вариант 1: Болдырев А., Горячев М., Сапелкин Д.
	Вариант 2: Вагнер В., Куцый Д., Поддубный А.

	Дополнительно
	Срок выполнения задания – 3 недели, до 16.08.2021.
	Запись итогового занятия можно скачать по этой ссылке.

*/

#pragma region Задание 1. Вектор

/*
	——————————————————————————————————————————————————————————————————————————————————————————————————————————

	Задача 1 (обязательная, максимум 8 баллов)
	В векторе, состоящем из п целых элементов, выполнить следующие операции (по
	командам меню):
	1)	количество элементов вектора, равных 0
	2)	сумму элементов вектора, расположенных после минимального элемента
	3)	удалить элементы, встречающиеся менее двух раз
	4)	упорядочить вектор по возрастанию модулей элементов
	5)	продублировать отрицательные элементы вектора
	6)	сохранить вектор в бинарном файле при помощи потока вывода
	7)	прочитать вектор из бинарного файла при помощи потока ввода

	——————————————————————————————————————————————————————————————————————————————————————————————————————————
*/

// Задание 1. Вектор
void App::task1()
{
	// для вывода в строку средствами C++
	ostringstream oss;

	// TODO: Ваше приложение
	App app;

	// константы для swith меню
	enum Commands {
		// 1. Заполнение вектора 
		CMD_POINT_ONE,
		// 2. Количество элементов вектора, равных 0
		CMD_POINT_TWO,
		// 3. Сумму элементов вектора, расположенных после минимального элемента
		CMD_POINT_THREE,
		// 4. Удалить элементы, встречающиеся менее двух раз
		CMD_POINT_FOUR,
		// 5. Упорядочить вектор по возрастанию модулей элементов
		CMD_POINT_FIVE,
		// 6. Продублировать отрицательные элементы вектора
		CMD_POINT_SIX,
		// 7. Сохранить вектор в бинарном файле при помощи потока вывода
		CMD_POINT_SEVEN,
		// 8. Прочитать вектор из бинарного файла при помощи потока ввода
		CMD_POINT_EIGHT
	};

	// количество пунктов меню
	const int N_MENU = 9;

	/*
		1)	количество элементов вектора, равных 0
		2)	сумму элементов вектора, расположенных после минимального элемента
		3)	удалить элементы, встречающиеся менее двух раз
		4)	упорядочить вектор по возрастанию модулей элементов
		5)	продублировать отрицательные элементы вектора
		6)	сохранить вектор в бинарном файле при помощи потока вывода
		7)	прочитать вектор из бинарного файла при помощи потока ввода
	*/

	MenuItem items[N_MENU] = {
		MenuItem("1. Заполнение вектора", CMD_POINT_ONE),
		MenuItem("2. Количество элементов вектора, равных 0", CMD_POINT_TWO),
		MenuItem("3. Сумму элементов вектора, расположенных после минимального элемента", CMD_POINT_THREE),
		MenuItem("4. Удалить элементы, встречающиеся менее двух раз", CMD_POINT_FOUR),
		MenuItem("5. Упорядочить вектор по возрастанию модулей элементов", CMD_POINT_FIVE),
		MenuItem("6. Продублировать отрицательные элементы вектора", CMD_POINT_SIX),
		MenuItem("7. Сохранить вектор в бинарном файле при помощи потока вывода", CMD_POINT_SEVEN),
		MenuItem("8. Прочитать вектор из бинарного файла при помощи потока ввода", CMD_POINT_EIGHT),

		// выход из программы
		MenuItem("Выход",  Menu::CMD_QUIT)
	};

	// количество цветов 
	const int N_PALETTE = 5;

	// массив цветов
	short palette[N_PALETTE] = { WHITE_ON_BLACK, LTCYAN_ON_BLACK, BLACK_ON_LTCYAN, GRAY_ON_BLACK };

	// объект меню
	Menu mainMenu("Главное меню приложения", items, N_MENU, palette, COORD{ 5, 5 });

	while (true)
	{
		try {
			cout << color(palette[Menu::PAL_CONSOLE]) << cls;
			int cmd = mainMenu.Navigate();
			cout << color(palette[Menu::PAL_CONSOLE]) << cls;
			if (cmd == Menu::CMD_QUIT) return;

			cls();

			switch (cmd)
			{
				// 1. Заполнение вектора
			case CMD_POINT_ONE:
				app.taskOneFillVector();
				break;
				// 2. Количество элементов вектора, равных 0
			case CMD_POINT_TWO:
				app.taskOneCountNull();
				break;
				// 3. Сумму элементов вектора, расположенных после минимального элемента
			case CMD_POINT_THREE:
				app.taskOneSummElem();
				break;
				// 4. Удалить элементы, встречающиеся менее двух раз
			case CMD_POINT_FOUR:
				app.taskOneDeleteDouble();
				break;
				// 5. Упорядочить вектор по возрастанию модулей элементов
			case CMD_POINT_FIVE:
				app.taskOneSortByModule();
				break;
				// 6. Продублировать отрицательные элементы вектора
			case CMD_POINT_SIX:
				app.taskOneDoubleNegative();
				break;
				// 7. Сохранить вектор в бинарном файле при помощи потока вывода
			case CMD_POINT_SEVEN:
				app.taskOneSaveBinFile();
				break;
				// 8. Прочитать вектор из бинарного файла при помощи потока ввода
			case CMD_POINT_EIGHT:
				app.taskOneLoadBinFile();
				break;
			}

			cout << "\n\n";
			getKey();
		}
		catch (exception& ex) {
			oss.str("");  // очистка строки - буфера вывода
			oss << "\n\t" << ex.what() << "\n";

			// вывод строки с сообщением об ошибке в цвете
			cputs(oss.str().c_str(), errColor);

			getKey();
		} // try-catch
	}
}

#pragma region Реализация функций 

// 1. Заполнение вектора 
void App::taskOneFillVector()
{
	showNavBarMessage(hintColor, "  1. Заполнение вектора");

	cout << "\n";

	// вывод вектора до заполнения
	showVector(vec_, "Вектор", "Вектор до заполнения");

	// отчистка вектора и создание с заданной длиной
	vec_ = vector<int>(getRand(7, 9));

	// анимация отчистки 

	// заполнение вектора 
	generate(vec_.begin(), vec_.end(), []() {return getRand(-5, 5); });

	// анимация заполнения 

	cout << "\n\n\n";

	// вывод после заполнения 
	showVector(vec_, "Вектор", "Вектор после заполнения");
}

// 2. Количество элементов вектора, равных 0
void App::taskOneCountNull()
{
	showNavBarMessage(hintColor, "  2. Количество элементов вектора, равных 0");

	cout << "\n";

	// вывод вектора 
	showVector(vec_, "Вектор", "Исходный вектор", showElemVectorNull);

	// подсчёт нулевых елементов
	int countNull = count_if(vec_.begin(), vec_.end(), [](int n) { return n == 0; });

	// анимация подсчёта 

	// текущий цвет по умолчанию
	short cl = getColor();

	// вывод количества элементов 
	cout << color(LTYELLOW_ON_BLACK) << "\n\n     Количество элементов со значением 0: " << color(LTGREEN_ON_BLACK) << countNull << color(cl);
}

// вывод элементов с подсветкой елементов со значением 0
void App::showElemVectorNull(vector<int> vec)
{
	// если вектор пуст 
	if (vec.empty())
	{
		cout << color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "     Индекс     " << color(LTCYAN_ON_BLACK) << " | "
			<< setw(90) << "|\n"
			<< "     +——————————————————+                                       "
			<< color(LTRED_ON_BLACK) << "  НЕТ ДАННЫХ  " << color(LTCYAN_ON_BLACK)
			<< "                                    |\n"
			<< color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "    Значение    " << color(LTCYAN_ON_BLACK) << " | "
			<< setw(90) << "|\n"
			<< "     +——————————————————+—————————————————————————————————————————————————————————————————————————————————————————+\n";

		return;
	}

	cout << color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "     Индекс     "
		<< color(LTCYAN_ON_BLACK) << " | ";

	// индекс 
	int i = 0;

	// вывод индексов 
	for_each(vec.begin(), vec.end(), [i](int value) mutable 
	{
		cout << color(value == 0 ? LTMAGENTA_ON_BLACK : LTYELLOW_ON_BLACK) << setw(2)
			<< i++ << color(LTCYAN_ON_BLACK) << " | ";
	});

	cout << "\n";

	// вывод разделительной полосы
	showLineVector();

	cout << color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "    Значение    "
		<< color(LTCYAN_ON_BLACK) << " | ";

	// вывод элементов 
	for_each(vec.begin(), vec.end(), [](int value) mutable 
	{
		cout << color(value == 0 ? LTMAGENTA_ON_BLACK : LTGREEN_ON_BLACK) << setw(2)
			<< value << color(LTCYAN_ON_BLACK) << " | ";
	});

	cout << "\n";

	// вывод разделительной полосы
	showLineVector();
}

// 3. Сумму элементов вектора, расположенных после минимального элемента
void App::taskOneSummElem()
{
	showNavBarMessage(hintColor, "  3. Сумму элементов вектора, расположенных после минимального элемента");

	cout << "\n";

	// вывод вектора 
	showVector(vec_, "Вектор", "Исходный вектор", showElemVectorMin);

	// поиск минимального элемента 
	auto pos = min_element(vec_.begin(), vec_.end());

	// сумма элементов после минимального 
	int sum = 0;

	// подсчёт суммы элементов после минимального
	sum = accumulate(pos + 1, vec_.end(), sum);

	// текущий цвет 
	short cl = getColor();

	// вывод суммы элементов после минимального элемента 
	cout << color(LTYELLOW_ON_BLACK) << "\n\n\n     Сумма элементов после минимального: " 
		<< color(LTGREEN_ON_BLACK) << sum << color(cl) << "\n\n\n\n\n";

}

// вывод элементов с подсветкой первого минимального элемента 
void App::showElemVectorMin(vector<int> vec)
{
	// если вектор пуст 
	if (vec.empty())
	{
		cout << color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "     Индекс     " << color(LTCYAN_ON_BLACK) << " | "
			<< setw(90) << "|\n"
			<< "     +——————————————————+                                       "
			<< color(LTRED_ON_BLACK) << "  НЕТ ДАННЫХ  " << color(LTCYAN_ON_BLACK)
			<< "                                    |\n"
			<< color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "    Значение    " << color(LTCYAN_ON_BLACK) << " | "
			<< setw(90) << "|\n"
			<< "     +——————————————————+—————————————————————————————————————————————————————————————————————————————————————————+\n";

		return;
	}

	cout << color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "     Индекс     " 
		<< color(LTCYAN_ON_BLACK) << " | ";

	// минимальный элемент
	auto min = min_element(vec.begin(), vec.end());

	// флаг указывает является ли элемент первым минимальным
	bool flagMin = false;

	// индекс 
	int i = 0;

	// вывод индексов 
	for_each(vec.begin(), vec.end(), [i, flagMin, min](int value) mutable { 

		cout << color(!flagMin and value == *min ? LTMAGENTA_ON_BLACK : flagMin ? LTYELLOW_ON_BLACK : YELLOW_ON_BLACK) << setw(2) 
			<< i++ << color(LTCYAN_ON_BLACK) << " | "; 

		// если значение элемента равно минимальному
		if (value == *min)
			flagMin = true;
		});

	cout << "\n";

	// вывод разделительной полосы
	showLineVector();

	cout << color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "    Значение    " 
		<< color(LTCYAN_ON_BLACK) << " | ";

	// вывод элементов 
	for_each(vec.begin(), vec.end(), [flagMin, min](int value) mutable {

		cout << color(!flagMin and value == *min ? LTMAGENTA_ON_BLACK : flagMin ? LTGREEN_ON_BLACK : GREEN_ON_BLACK) << setw(2)
			<< value << color(LTCYAN_ON_BLACK) << " | ";

		// если значение элемента равно минимальному
		if (value == *min)
			flagMin = true;
		});

	cout << "\n";

	// вывод разделительной полосы
	showLineVector();
}

// 4. Удалить элементы, встречающиеся менее двух раз
void App::taskOneDeleteDouble()
{
	showNavBarMessage(hintColor, "  4. Удалить элементы, встречающиеся менее двух раз");

	cout << "\n";

	// вывод вектора 
	showVector(vec_, "Вектор", "Исходный вектор", showElemVectorRem);

	cout << "\n\n\n";

	// удаление элементов вектора, встречающихся меньше двух раз
	for (int i = 0; i < vec_.size(); i++)
	{
		// текущее значение 
		int val = vec_[i];

		// если элементов с теущим значеним меньше двух 
		if (count_if(vec_.begin(), vec_.end(), [val](int value) { return value == val;}) < 2)
		{
			// удаление элементов по значению
			vec_.erase(remove_if(vec_.begin(), vec_.end(), [val](int value) { return value == val; }));

			// обнуление индекса 
			i = 0;
		}
	}

	// вывод вектора 
	showVector(vec_, "Вектор", "Вектор после удаления", showElemVectorRem);
}

// вывод элементов с подсветкой элементов встречающихся менее двух раз 
void App::showElemVectorRem(vector<int> vec)
{
	// если вектор пуст 
	if (vec.empty())
	{
		cout << color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "     Индекс     " << color(LTCYAN_ON_BLACK) << " | "
			<< setw(90) << "|\n"
			<< "     +——————————————————+                                       "
			<< color(LTRED_ON_BLACK) << "  НЕТ ДАННЫХ  " << color(LTCYAN_ON_BLACK)
			<< "                                    |\n"
			<< color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "    Значение    " << color(LTCYAN_ON_BLACK) << " | "
			<< setw(90) << "|\n"
			<< "     +——————————————————+—————————————————————————————————————————————————————————————————————————————————————————+\n";

		return;
	}

	cout << color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "     Индекс     "
		<< color(LTCYAN_ON_BLACK) << " | ";

	// индекс 
	int i = 0;

	// ссылка на вектор 
	auto& vecLink = vec;

	// вывод индексов 
	for_each(vec.begin(), vec.end(), [i, vec](int value) mutable {

		cout << color(count_if(vec.begin(), vec.end(), [value](int val) { return value == val; }) < 2 ? LTMAGENTA_ON_BLACK : LTYELLOW_ON_BLACK) << setw(2)
			<< i++ << color(LTCYAN_ON_BLACK) << " | ";
		});

	cout << "\n";

	// вывод разделительной полосы
	showLineVector();

	cout << color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "    Значение    "
		<< color(LTCYAN_ON_BLACK) << " | ";

	// вывод элементов 
	for_each(vec.begin(), vec.end(), [vec](int value) mutable {

		cout << color(count_if(vec.begin(), vec.end(), [value](int val) { return value == val; }) < 2 ? LTMAGENTA_ON_BLACK : LTGREEN_ON_BLACK) << setw(2)
			<< value << color(LTCYAN_ON_BLACK) << " | ";
		});

	cout << "\n";

	// вывод разделительной полосы
	showLineVector();
}

// 5. Упорядочить вектор по возрастанию модулей элементов
void App::taskOneSortByModule()
{
	showNavBarMessage(hintColor, "  5. Упорядочить вектор по возрастанию модулей элементов");

	cout << "\n";

	// вывод вектора 
	showVector(vec_, "Вектор", "Вектор до сортировки");

	cout << "\n\n\n";

	// сортировка 
	sort(vec_.begin(), vec_.end(), [](int val1, int val2) { return abs(val1) < abs(val2); });

	// вывод вектора 
	showVector(vec_, "Вектор", "Вектор после сортировки");

}

// 6. Продублировать отрицательные элементы вектора
void App::taskOneDoubleNegative()
{
	showNavBarMessage(hintColor, "  6. Продублировать отрицательные элементы вектора");

	// вывод вектора 
	showVector(vec_, "Вектор", "Вектор до дублирования", showElemVectorNegative);

	// итератор для поиска отрицательных элементов
	auto it = vec_.begin();

	// дублирование отрицательных элементов
	while(true)
	{
		// поиск отрицательного элемента 
		it = find_if(it, vec_.end(), [](int value) { return value < 0; });
		
		// если элемент не найден то выход из цикла
		if (it == vec_.end())
			break;

		// дублирование отрицательного элемента 
		it = vec_.insert(it, *it) + 2;
	}

	// вывод вектора 
	showVector(vec_, "Вектор", "Вектор после дублирования", showElemVectorNegative);

	cout << "\n\n";
}

// вывод элементов с подсветкой отрицательных елементов
void App::showElemVectorNegative(vector<int> vec)
{
	// если вектор пуст 
	if (vec.empty())
	{
		cout << color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "     Индекс     " << color(LTCYAN_ON_BLACK) << " | "
			<< setw(90) << "|\n"
			<< "     +——————————————————+                                       "
			<< color(LTRED_ON_BLACK) << "  НЕТ ДАННЫХ  " << color(LTCYAN_ON_BLACK)
			<< "                                    |\n"
			<< color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "    Значение    " << color(LTCYAN_ON_BLACK) << " | "
			<< setw(90) << "|\n"
			<< "     +——————————————————+—————————————————————————————————————————————————————————————————————————————————————————+\n";

		return;
	}

	cout << color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "     Индекс     "
		<< color(LTCYAN_ON_BLACK) << " | ";

	// индекс 
	int i = 0;
	
	// вывод индексов 
	for_each(vec.begin(), vec.end(), [i](int value) mutable
		{
			cout << color(value < 0 ? LTMAGENTA_ON_BLACK : LTYELLOW_ON_BLACK) << setw(2)
				<< i++ << color(LTCYAN_ON_BLACK) << " | ";
		});
	
	cout << "\n";

	// вывод разделительной полосы
	showLineVector();

	cout << color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "    Значение    "
		<< color(LTCYAN_ON_BLACK) << " | ";

	// вывод элементов 
	for_each(vec.begin(), vec.end(), [](int value) mutable
		{
			cout << color(value < 0 ? LTMAGENTA_ON_BLACK : LTGREEN_ON_BLACK) << setw(2)
				<< value << color(LTCYAN_ON_BLACK) << " | ";
		});

	cout << "\n";

	// вывод разделительной полосы
	showLineVector();
}

// 7. Сохранить вектор в бинарном файле при помощи потока вывода
void App::taskOneSaveBinFile()
{
	showNavBarMessage(hintColor, "  7. Сохранить вектор в бинарном файле при помощи потока вывода");

	cout << "\n";

	// вывод вектора 
	showVector(vec_, "Вектор", "Вектор для сохранения в файл");

	// сохранение вектора в файл
	saveVectorBinFile(nameFileVector, vec_);

	cout << "\n\n\n";

	// отчистка вектора 
	vec_.clear();

	// считываение вектора из файла в вектор
	readVectorBinFile(nameFileVector, vec_);
	
	// вывода вектора 
	showVector(vec_, "Вектор", "Вектор из файла");

	cout << "\n\n\n";
}

// сохранение вектора в файл
void App::saveVectorBinFile(string nameFile, vector<int>& vec)
{
	// открытие потока для бинарной записи в файл 
	ofstream ofs(nameFile.c_str(), ios::binary | ios::trunc);

	// если поток открыт неуспешно
	if (!ofs.is_open())
	{
		throw exception(("App: Ошибка отрытия файла "s + nameFile).c_str());
	}

	// вывод в файл вектора 
	for_each(vec.begin(), vec.end(), [&ofs](int value) { ofs.write((char*)&value, sizeof(value)); });

	// закрытие потока 
	ofs.close();
}

// чтение вектора из файла
void App::readVectorBinFile(string nameFile, vector<int>& vec)
{
	// открытие потока для бинарного чтения
	ifstream ifs(nameFile, ios::binary | ios::beg | ios::in);

	// если поток открыт неуспешно
	if (!ifs.is_open())
	{
		throw exception(("App: Ошибка отрытия файла "s + nameFile).c_str());
	}

	// ввод из файла в вектор 
	while (true)
	{
		int tmp = 0;
		ifs.read((char*)&tmp, sizeof(tmp));

		if (ifs.eof()) break;
	
		vec.push_back(tmp);
	}

	// закрытие потока 
	ifs.close();
}

// 8. Прочитать вектор из бинарного файла при помощи потока ввода
void App::taskOneLoadBinFile()
{
	showNavBarMessage(hintColor, "  8. Прочитать вектор из бинарного файла при помощи потока ввода");

	cout << "\n";

	// вывод вектора 
	showVector(vec_, "Вектор", "Вектор до загрузки");

	cout << "\n\n\n";

	// отчистка вектора 
	vec_.clear();

	// считываение вектора из файла в вектор
	readVectorBinFile(nameFileVector, vec_);

	// вывод вектора 
	showVector(vec_, "Вектор", "Вектор после загрузки");

	cout << "\n\n\n";
}

#pragma region Общие методы 

// вывод вектора 
void App::showVector(vector<int> vec, string messageName, string messageInfo, void showElemFunc(vector<int> vec))
{
	// вывод шапки с информацией
	showHeadVector(vec, messageName, messageInfo);

	// вывод элементов 
	showElemFunc(vec);
}

// вывод шапки с информацией
void App::showHeadVector(vector<int> vec, string messageName, string messageInfo)
{
	//           |        18        |                  37                   |                         48                      |
	cout << color(LTCYAN_ON_BLACK)
		<< "     +——————————————————+———————————————————————————————————————+—————————————————————————————————————————————————+\n"
		<< "     | " << color(WHITE_ON_BLACK) << "Размер: " << color(LTGREEN_ON_BLACK) << setw(8) << vec.size() << color(LTCYAN_ON_BLACK) << " | "
		<< left
		<< color(WHITE_ON_BLACK) << "Название: " << color(LTYELLOW_ON_BLACK) << setw(27) << messageName << color(LTCYAN_ON_BLACK) << " | "
		<< color(WHITE_ON_BLACK) << "Описание: " << color(LTYELLOW_ON_BLACK) << setw(37) << messageInfo << color(LTCYAN_ON_BLACK) << " |\n"
		<< right;

	showLineVector();
}

// вывод элементов 
void App::showElemVector(vector<int> vec)
{
	// если вектор пуст 
	if (vec.empty())
	{
		cout << color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "     Индекс     " << color(LTCYAN_ON_BLACK) << " | "
			<< setw(90) << "|\n"
			<< "     +——————————————————+                                       " 
			<< color(LTRED_ON_BLACK) << "  НЕТ ДАННЫХ  " << color(LTCYAN_ON_BLACK) 
			<< "                                    |\n"
			<< color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "    Значение    " << color(LTCYAN_ON_BLACK) << " | "
			<< setw(90) << "|\n"
			<< "     +——————————————————+—————————————————————————————————————————————————————————————————————————————————————————+\n";
			
		return;
	}

	cout << color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "     Индекс     " << color(LTCYAN_ON_BLACK) << " | ";

	int i = 0;

	// вывод индексов 
	for_each(vec.begin(), vec.end(), [i](int vec) mutable { cout << color(LTYELLOW_ON_BLACK) << setw(2) << i++ << color(LTCYAN_ON_BLACK) << " | "; });

	cout << "\n";

	// вывод разделительной полосы
	showLineVector();

	cout << color(LTCYAN_ON_BLACK) << "     | " << color(WHITE_ON_BLACK) << "    Значение    " << color(LTCYAN_ON_BLACK) << " | ";

	// вывод элементов 
	for_each(vec.begin(), vec.end(), [](int vec) { cout << color(LTGREEN_ON_BLACK) << setw(2) << vec << color(LTCYAN_ON_BLACK) << " | "; });

	cout << "\n";

	// вывод разделительной полосы
	showLineVector();
}

// вывод разделительной линии
void App::showLineVector()
{
	// текущий цвет 
	short cl = getColor();

	//           |        18        |                                     4 x 18                                              |
	cout << color(LTCYAN_ON_BLACK)
		<< "     +——————————————————+————+————+————+————+————+————+————+————+————+————+————+————+————+————+————+————+————+————+\n"
		<< color(cl);
}

#pragma endregion 

#pragma endregion

#pragma endregion

#pragma region Задание 2. Библиотека

/*
	——————————————————————————————————————————————————————————————————————————————————————————————————————————

	Задача 2 (для претендентов на 10 баллов).
	С использованием классов и алгоритмов STL, лямбда-выражений написать приложение
	для решения следующей задачи из практикума Павловской Т.А. и Щупака Ю.А. по ООП
	на C++:

	Написать приложения для учета книг в библиотеке. Сведения о книгах содержат:
	идентификатор (учетный номер единицы хранения), фамилию и инициалы автора, название
	книги, год издания, количество экземпляров данной книги в библиотеке. Сведения о
	библиотеке – адрес библиотеки, фамилия и инициалы директора, коллекция книг. Данные
	о библиотеке и книгах хранить в текстовом файле в формате CSV, символ разделителя «;».
	Формат файла – в первой строке данные библиотеки, в остальных строках данные о книгах,
	одна книга – одна строка, начальная инициализация при первом запуске приложения – не
	менее 12 книг. С помощью меню реализовать выбор и выполнение следующих функций:
	•	Вывод данных библиотеки и коллекции книг в консоль
	•	Добавление книги, ввод данных с клавиатуры, сохранение измененной коллекции в
		текстовый файл
	•	Удаление книг по идентификатору, сохранение измененной коллекции в текстовый файл
	•	Изменение количества книг заданного автора на вводимое с клавиатуры значение,
		сохранение измененной коллекции в текстовый файл
	•	Отбор книг в отдельный список по заданному году издания, вывод этого списка в
		консоль, упорядочив по году издания, не изменять исходную коллекцию книг, файл
		данных
	•	Отбор заявок в отдельный список по автору, вывод этого списка в консоль, упорядочив
		по автору, не изменять исходную коллекцию книг, файл данных
	•	Сортировка книг по убыванию количества книг, вывод в консоль без изменения файла
		данных
	•	Сортировка книг по идентификатору, вывод в консоль без изменения файла данных
	•	Сортировка книг по названию, вывод в консоль без изменения файла данных
	Постарайтесь свести к минимуму использование циклов – максимально используйте алгоритмы
	STL.

	——————————————————————————————————————————————————————————————————————————————————————————————————————————
*/

// Задание 2. Библиотека
void App::task2()
{
	// для вывода в строку средствами C++
	ostringstream oss;

	// TODO: Ваше приложение
	App app;

	// константы для swith меню
	enum Commands {
		// Задание 1. Вектор
		CMD_POINT_ONE,
		// Задание 2. Библиотека
		CMD_POINT_TWO,
		// Задание 3. Телефонная станция
		CMD_POINT_THREE
	};

	// количество пунктов меню
	const int N_MENU = 4;

	MenuItem items[N_MENU] = {
		MenuItem("Задание 1. Вектор", CMD_POINT_ONE),
		MenuItem("Задание 2. Библиотека", CMD_POINT_TWO),
		MenuItem("Задание 3. Телефонная станция", CMD_POINT_THREE),

		// выход из программы
		MenuItem("Выход",  Menu::CMD_QUIT)
	};

	// количество цветов 
	const int N_PALETTE = 5;

	// массив цветов
	short palette[N_PALETTE] = { WHITE_ON_BLACK, LTCYAN_ON_BLACK, BLACK_ON_LTCYAN, GRAY_ON_BLACK };

	// объект меню
	Menu mainMenu("Главное меню приложения", items, N_MENU, palette, COORD{ 5, 5 });

	while (true)
	{
		try {
			cout << color(palette[Menu::PAL_CONSOLE]) << cls;
			int cmd = mainMenu.Navigate();
			cout << color(palette[Menu::PAL_CONSOLE]) << cls;
			if (cmd == Menu::CMD_QUIT) return;

			switch (cmd)
			{
				// Задание 1. Вектор
			case CMD_POINT_ONE:
				app.task1();
				break;
				// Задание 2. Библиотека
			case CMD_POINT_TWO:
				app.task2();
				break;
				// Задание 3. Телефонная станция
			case CMD_POINT_THREE:
				app.task3();
				break;
			}
		}
		catch (exception& ex) {
			oss.str("");  // очистка строки - буфера вывода
			oss << "\n\t" << ex.what() << "\n";

			// вывод строки с сообщением об ошибке в цвете
			cputs(oss.str().c_str(), errColor);

			getKey();
		} // try-catch
	}
}

#pragma endregion

#pragma region Задание 3. Телефонная станция

/*
	——————————————————————————————————————————————————————————————————————————————————————————————————————————

	Задача 3 (для претендентов на 12 баллов) – вариант 1
	Класс Bill представляет собой разовый платеж за телефонный разговор. Класс должен включать
	поля: дата и время начала разговора, дата и время окончания разговора.

	Время разговора вычисляется в минутах, неполная минута, считается за полную. Должен быть
	реализован метод, вычисляющий сумму к оплате за разговор.
	Для представления даты и времени используйте класс DateTime с полями – день, месяц, год,
	час, минута, секунда. Реализуйте методы вычисления разности между двумя моментами времени
	в секундах. Перегрузите операции сравнения двух моментов времени.

	Разработайте класс – список плательщиков ListPayer. Класс содержит список плательщиков за
	телефонные услуги, дату создания списка, номер списка.

	Один элемент списка включает: информацию о плательщике – номер телефона, фамилия и инициалы,
	фамилия и инициалы плательщика, номер телефона, тариф за минуту разговора, скидка (в процентах),
	коллекция записей класса Bill, дату платежа, сумму платежа.

	Реализовать для класса ListPayer:
	•	Метод добавления плательщика в список
	•	Метод удаления плательщика из списка
	•	Метод поиска плательщика по номеру телефона, найденные записи помещать в отдельную коллекцию,
		сохранять в бинарном потоке вывода
	•	Метод поиска плательщика по фамилии и инициалам, найденные записи помещать в отдельную
		коллекцию, сохранять в бинарном потоке вывода
	•	Метод поиска плательщиков по дате платежа, найденные записи помещать в отдельную коллекцию,
		сохранять в бинарном потоке вывода
	•	Метод вычисления полной стоимости платежей всего списка
	Реализовать создание объектов ListPayer, операции объединения и пересечения списков.
	•	Операция объединения списка – бинарная операция, на выходе получаем список из элементов двух
		списков, без дубликатов.
	•	Операция пересечения списка – бинарная операция, на выходе получаем список из элементов
		имеющихся и в первом, и во втором списках, без дубликатов.
	Реализовать отбор данных из списка плательщиков:
	•	По дате платежа, сортировка по номеру телефона
	•	По номеру телефона, сортировка по номеру телефона
	Реализовать сортировку списка плательщиков:
	•	По номеру телефона
	•	По убыванию суммы к оплате
	•	По убыванию времени разговоров

	——————————————————————————————————————————————————————————————————————————————————————————————————————————
*/

// Задание 3. Телефонная станция
void App::task3()
{
	// для вывода в строку средствами C++
	ostringstream oss;

	// TODO: Ваше приложение
	App app;

	// константы для swith меню
	enum Commands {
		// Задание 1. Вектор
		CMD_POINT_ONE,
		// Задание 2. Библиотека
		CMD_POINT_TWO,
		// Задание 3. Телефонная станция
		CMD_POINT_THREE
	};

	// количество пунктов меню
	const int N_MENU = 4;

	MenuItem items[N_MENU] = {
		MenuItem("Задание 1. Вектор", CMD_POINT_ONE),
		MenuItem("Задание 2. Библиотека", CMD_POINT_TWO),
		MenuItem("Задание 3. Телефонная станция", CMD_POINT_THREE),

		// выход из программы
		MenuItem("Выход",  Menu::CMD_QUIT)
	};

	// количество цветов 
	const int N_PALETTE = 5;

	// массив цветов
	short palette[N_PALETTE] = { WHITE_ON_BLACK, LTCYAN_ON_BLACK, BLACK_ON_LTCYAN, GRAY_ON_BLACK };

	// объект меню
	Menu mainMenu("Главное меню приложения", items, N_MENU, palette, COORD{ 5, 5 });

	while (true)
	{
		try {
			cout << color(palette[Menu::PAL_CONSOLE]) << cls;
			int cmd = mainMenu.Navigate();
			cout << color(palette[Menu::PAL_CONSOLE]) << cls;
			if (cmd == Menu::CMD_QUIT) return;

			switch (cmd)
			{
				// Задание 1. Вектор
			case CMD_POINT_ONE:
				app.task1();
				break;
				// Задание 2. Библиотека
			case CMD_POINT_TWO:
				app.task2();
				break;
				// Задание 3. Телефонная станция
			case CMD_POINT_THREE:
				app.task3();
				break;
			}
		}
		catch (exception& ex) {
			oss.str("");  // очистка строки - буфера вывода
			oss << "\n\t" << ex.what() << "\n";

			// вывод строки с сообщением об ошибке в цвете
			cputs(oss.str().c_str(), errColor);

			getKey();
		} // try-catch
	}
}

#pragma endregion