/*
 * Задача 1.
 * При помощи STL, с использованием алгоритмов, лямбда-выражений, потоковых
 * итераторов написать консольное приложение, обрабатывающее векторы
 * по заданию:
 *     • Сформировать вектор из случайных вещественных чисел, диапазон
 *       генерации вводите с клавиатуры. Сохранить вектор в форматированном
 *       потоке вывода при помощи потокового итератора
 *     • Прочитать вектор из форматированного потока ввода при помощи
 *       потокового итератора. Умножить все элементы вектора на 2. Сохранить
 *       вектор в форматированном потоке вывода при помощи потокового итератора
 *     • Прочитать вектор из форматированного потока ввода при помощи
 *       потокового итератора. Упорядочить вектор по правилу – положительные в
 *       начало вектора. Вывести вектор с цветовым выделением положительных
 *       элементов
 *     • Прочитать вектор из форматированного потока ввода при помощи
 *       потокового итератора. Упорядочить вектор по убыванию. Вывести
 *       вектор с цветовым выделением отрицательных элементов
 *
 * Задача 2.
 * Сведения о каждом автобусе содержат: регистрационный номер автобуса,
 * фамилию и инициалы водителя, назначенный номер маршрута, фактический номер
 * маршрута.
 * Нахождение в парке – особый маршрут с номером «0», в состав номера маршрута
 * входят как цифры, так и буквы, например – «42», «42а», «32в». Коллекцию
 * заявок постройте на классе vector. Хранить коллекцию в форматированном
 * потоке вывода, запись/чтение файла реализуйте при помощи потокового
 * итератора. При первом запуске приложения запишите начальные данные в файл из
 * вектора инициирующих значений.
 * Программа должна обеспечивать выбор с помощью меню и выполнение одной из
 * следующих функций:
 *     • запись данных об автобусах в текстовый файл (форматированный поток
 *       вывода)
 *     • чтение данных об автобусах из текстового файла (форматированного
 *       потока ввода)
 *     • вывод данных об автобусах при помощи алгоритма for_each() и лямбда-
 *       выражения
 *     • упорядочить коллекцию автобусов по регистрационным номерам при помощи
 *       алгоритма sort() и лямбда-выражения – компаратора; 
 *     • упорядочить коллекцию автобусов по фамилии и инициалам водителя при
 *       помощи алгоритма sort() и лямбда-выражения – компаратора;
 * Постарайтесь свести к минимуму использование циклов – максимально используйте
 * алгоритмы STL.
 * 
 */


#include "pch.h"
#include "Utils.h"
#include "MenuItem.h"
#include "Menu.h"
#include "App.h"
#include "Palette.h"

int main()
{
	// настройка вывода в консоль
	init(L"Занятие 22.07.2021 - алгоритмы, лямбда-выражения");

	// коды команд
    enum Commands {
    	CMD_ONE,      // Обработка вектора при помощи лямбда-выражений
    	CMD_TWO,      // Запись данных об автобусах в текстовый файл (форматированный поток вывода)
    	CMD_THREE,    // Чтение данных об автобусах из текстового файла (форматированного потока ввода)
    	CMD_FOUR,     // Вывод данных об автобусах при помощи алгоритма for_each() и лямбда-выражений
    	CMD_FIVE,     // Упорядочить коллекцию автобусов по регистрационным номерам, использовать sort()
    	CMD_SIX       // Упорядочить коллекцию автобусов по фамилии и инициалам водителя, использовать sort()
    };

	// массив пунктов меню
    const int N_MENU = 7;
    MenuItem items[N_MENU] = {
        MenuItem ("Обработка вектора при помощи лямбда-выражений", CMD_ONE), 
        MenuItem ("Запись данных об автобусах в текстовый файл (форматированный поток вывода)", CMD_TWO), 
        MenuItem ("Чтение данных об автобусах из текстового файла (форматированного потока ввода)", CMD_THREE), 
        MenuItem ("Вывод данных об автобусах при помощи алгоритма for_each() и лямбда-выражений", CMD_FOUR), 
        MenuItem ("Упорядочить коллекцию автобусов по регистрационным номерам, использовать sort()", CMD_FIVE), 
        MenuItem ("Упорядочить коллекцию автобусов по фамилии и инициалам водителя, использовать sort()", CMD_SIX), 
        MenuItem ("Выход",  Menu::CMD_QUIT) 
    };

	// палитра вывода меню
    const int N_PALETTE = 5;
	//                          заголовок       пункт меню       выбранный пункт  текст консоли  
    short palette[N_PALETTE] = {arrColor, LTCYAN_ON_BLACK, BLACK_ON_LTCYAN, mainColor};

    Menu mainMenu("Главное меню приложения", items, N_MENU, palette, COORD{5, 5});

	// Объект класса для обработки по заданию
    App *app = new App();   
    
    while(true) {
        try {
            cout << color(palette[Menu::PAL_CONSOLE]) << cls;
            showNavBarMessage(hintColor, "  Работа с контейнером объектов");
            int cmd = mainMenu.Navigate();
            cout << color(palette[Menu::PAL_CONSOLE]) << cls;
            if (cmd == Menu::CMD_QUIT) break;

            switch (cmd) {
            // Обработка вектора при помощи лямбда-выражений
            case CMD_ONE:
                app->demoVector();
                break;
            	
            // Запись данных об автобусах в текстовый файл (форматированный поток вывода)
            case CMD_TWO:
                app->demoInitializeAndWrite();
                break;
            	
            // Чтение данных об автобусах из текстового файла (форматированного потока ввода)
            case CMD_THREE:
                app->demoReadAndShow();
                break;
            
            // Вывод данных об автобусах при помощи алгоритма for_each() и лямбда-выражений
            case CMD_FOUR:
                app->demoShowBuses();
                break;
            	
            // Упорядочить коллекцию автобусов по регистрационным номерам, использовать sort()
            case CMD_FIVE:
                app->demoOrderByRegNumber();
                break;
            	
            // Упорядочить коллекцию автобусов по фамилии и инициалам водителя, использовать sort()
            case CMD_SIX:
                app->demoOrderByFullName();
                break;
            } // switch

        } catch (exception &ex) {
            setColor(mainColor);
            cls();
            showNavBarMessage(hintColor, "  Ошибка приложения, нажмите любую клавишу для продолжения...");

	        // добавим 4 пробела перед выводимым сообщением об ошибке, длина строки 64 символа
            char buf[65];
            sprintf(buf, "    %-60s", ex.what());

        	// в эту секцию передается управление оператором throw
            const char* msg[] = {
                " ",
                "    [Ошибка]",
                buf,
                " ",
                " ",
                nullptr
            };
            showMessage(8, 4, 64, msg, errColor);
        } // try-catch
        cout << endlm(2);
        getKey();
    } // while

    cout << cls << pos(0,24);
    getKey();
	
    delete app;
    return 0;
} // main