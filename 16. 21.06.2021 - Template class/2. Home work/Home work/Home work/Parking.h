#pragma once

#include "Stack.h"
#include "Car.h"
/*
	При помощи шаблонного класса Stack (с ограничением во внешнем классе
	емкости до 12 элементов) для представления полос парковки, решите задачу
	моделирования парковки автомобилей у магазина, в котором и приобретался товар.
	 
	Автомобили могут ставиться на парковку только в начало парковочной полосы,
	автомобили могут забираться с парковкитолько с начала полосы. Но владельцы 
	могут забирать автомобили в произвольном порядке. Для этого машины с начала 
	парковочной полосы перемещаются на маневровую полосу, до машины, которую 
	требуется забрать. Эта машина покидает парковочную полосу, затем машины с 
	маневровой полосы возвращаются на парковочную. 

	В классе Parking реализуйте методы добавления автомобиля на парковку,
	изъятия произвольного автомобиля с парковки.
*/

// КЛАСС ПАРКОВКИ
class Parking
{
public:

	// количество мест для парковки
	static const int PARK_PLACE_MAX = 12;

private:

	// полоса парковки
	Stack<Car> parkLane_;

	// полоса манёвров
	Stack<Car> manLane_;

public:

#pragma region Конструкторы, дестркутор и операция присваивания

	// конструктор по умолчанию
	Parking() = default;

	// констркутор инициализирующий (на базе массива Car)
	Parking(Car* car, int n)
	{
		// если длина массива меньше или равна нулю
		if (n <= 0)
			throw exception("Parking: Размер массива автомобилей должен быть больше нуля!");

		parkLane_.pushAll(car, n);
	}

	// констркутор копирующий
	Parking(const Parking& parking) = default;

	// дестркутор 
	~Parking() = default;

	// перегрузка операции присваивания
	Parking& operator=(Parking& parking) = default;

#pragma endregion

#pragma region Методы

	// добавить автомобиль
	void push(Car car);
	
	// добавить массив автомобилей
	void pushAll (Car* car, int n);

	// забрать последний автомобиль
	Car pop();

	// забрать любой автомобиль 
	Car popAny(int index);

	// забрать все автомобили
	void clear();

	// вывод автомобилей в цвете
	void showColor();

	// поиск цвета автомобиля в базе по названию цвета 
	short colorCar(char* color);

	// количество машин на полосе парковки
	int getCounterPark() { return parkLane_.getCounter(); }

	// количество машин на полосе маневрирования
	int getCounterMan() { return manLane_.getCounter(); }

	// перегрузка операции вывода 
	friend ostream& operator<<(ostream& os, Parking& park);

#pragma endregion
};

