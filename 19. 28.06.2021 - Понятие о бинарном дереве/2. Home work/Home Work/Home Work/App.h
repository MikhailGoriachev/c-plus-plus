#pragma once
#include "pch.h"
#include "Utils.h"

#include "menu.h"
#include "MenuItem.h"
#include "Palette.h"

#include "DblList.h"
#include "Person.h"

#include "Form.h"
#include "Queue.h"
/*
	Задача 1.
		Реализуйте класс Person, представляющий данные о жителе некоторого города,
		поля класса фамилия, имя, отчество (все три поля типа char *), роств
		сантиметрах (тип double), вес в килограммах (тип double), город проживания
		(тип char *).
		Создайте список экземпляр класса двусвязного списка DblList<Person>, не
		менее 12 узлов. Закодируйте обработки (при помощи итератора):
		•	изменить вес каждого жителя на некоторое случайное значение (для каждого
			жителя значение свое, но не более 0.5% от веса жителя)
		•	скопировать в отдельный список DblList<Person>жителей заданного города,
			название города вводить с клавиатуры

	Задача 2.
		С использованием шаблонного класса очереди с итератором реализовать очередь
		нуждающихся в улучшении жилищных условий. Заполняйте очереди из массивов, на
		менее 10 элементов в массиве.
		Элемент очереди должен хранить фамилию, имя и отчество претендента,
		количество членов семьи, площадь квартиры в м2, количество комнат, дату
		постановки на учет (день, месяц, год–класс Date). Очередь имеет название,
		хранит имя бинарного файла для данных.

		Реализовать дополнительно операции (при помощи итераторов):

		•	Скопировать в двусвязный список (шаблонный класс DblList<>из предыдущих
			занятий) все записи очерединуждающихся в улучшении жилищных условий с
			заданным количеством комнат. Количество комнат вводить с клавиатуры
		•	Скопировать в другую очередь нуждающихся в улучшении жилищных условий
			записи исходной очереди с заданным диапазоном площади квартиры. Диапазон
			площадей вводить с клавиатуры
*/


// TODO: прикладная часть - полезная работа приложения - бизнес-логика приложения
class App
{
	// Задание 1. Двусвязный список жителей города
	DblList<Person> listPerson_;

	// Задание 2. Очередь нуждающихся в улучшении жилищных условий
	Queue<Form> forms_;

public:

	// констркуктор по умолчанию 
	App()
	{
		// инициализация списка с жителями 
		Person persons[12]
		{
			Person("Крылов", "Владислав", "Даниилович", getRand(140., Person::HEIGHT_MAX - 100), getRand(40., Person::WEIGHT_MAX - 170), "Донецк"),
			Person("Евдокимов", "Августин", "Никитевич", getRand(140., Person::HEIGHT_MAX - 100), getRand(40., Person::WEIGHT_MAX - 170), "Днепр"),
			Person("Алексеев", "Дмитрий", "Денисович", getRand(140., Person::HEIGHT_MAX - 100), getRand(40., Person::WEIGHT_MAX - 170), "Николаев"),
			Person("Рябов", "Клемент", "Константинович", getRand(140., Person::HEIGHT_MAX - 100), getRand(40., Person::WEIGHT_MAX - 170), "Донецк"),
			Person("Лыткин", "Бронислав", "Аркадьевич", getRand(140., Person::HEIGHT_MAX - 100), getRand(40., Person::WEIGHT_MAX - 170), "Днепр"),
			Person("Григорьев", "Ираклий", "Натанович", getRand(140., Person::HEIGHT_MAX - 100), getRand(40., Person::WEIGHT_MAX - 170), "Запорожье"),
			Person("Максимова", "Ева", "Максовна", getRand(140., Person::HEIGHT_MAX - 100), getRand(40., Person::WEIGHT_MAX - 170), "Николаев"),
			Person("Карпов", "Любомир", "Артёмович", getRand(140., Person::HEIGHT_MAX - 100), getRand(40., Person::WEIGHT_MAX - 170), "Запорожье"),
			Person("Жданов", "Нисон", "Русланович", getRand(140., Person::HEIGHT_MAX - 100), getRand(40., Person::WEIGHT_MAX - 170), "Донецк"),
			Person("Доронина ", "Роза", "Аристарховна", getRand(140., Person::HEIGHT_MAX - 100), getRand(40., Person::WEIGHT_MAX - 170), "Николаев"),
			Person("Овчинникова", "Розалина", "Максимовна", getRand(140., Person::HEIGHT_MAX - 100), getRand(40., Person::WEIGHT_MAX - 170), "Донецк"),
			Person("Корнилов", "Панкратий", "Павлович", getRand(140., Person::HEIGHT_MAX - 100), getRand(40., Person::WEIGHT_MAX - 170), "Запорожье")
		};

		listPerson_.addAll(persons, 12);

		// инициализация очереди нуждающихся в улучшении жилищных условий
		Form tmpForm[10]{
			Form("Крылов", "Владислав", "Даниилович", 3, getRand(68., 82.), 3, Date(15, 12, 2003)),
			Form("Евдокимов", "Августин", "Никитевич", 1, getRand(36., 42.), 2, Date(6, 4, 2010)),
			Form("Алексеев", "Дмитрий", "Денисович", 2, getRand(54., 62.), 3, Date(30, 5, 2012)),
			Form("Рябов", "Клемент", "Константинович", 3, getRand(68., 82.), 5, Date(28, 2, 2021)),
			Form("Лыткин", "Бронислав", "Аркадьевич", 2, getRand(54., 62.), 4, Date(29, 2, 2016)),
			Form("Григорьев", "Ираклий", "Натанович", 1, getRand(36., 42.), 1, Date(3, 1, 1999)),
			Form("Максимова", "Ева", "Максовна", 1, getRand(36., 42.), 3, Date(25, 6, 2001)),
			Form("Карпов", "Любомир", "Артёмович", 2, getRand(54., 62.), 4, Date(23, 7, 2006)),
			Form("Жданов", "Нисон", "Русланович", 1, getRand(36., 42.), 3, Date(18, 3, 2004)),
			Form("Доронина ", "Роза", "Аристарховна", 2, getRand(54., 62.), 2, Date(17, 5, 2002))
		};

		forms_.enqueueAll(tmpForm, 10);
	}

	// конструктор копирующий
	App(const App& app) : App() {}

	// деструктор 
	~App() = default;
	
	// перегрузка операции присваивания
	App& operator=(const App& app) = default;

#pragma region Задача 1. Данные о жителе города

	// Задача 1. Данные о жителе города
	void task1();

private:

	// Изменить вес каждого жителя на некоторое случайное значение
	void taskOneAddWeight();

	// Скопировать в отдельный список жителей заданного города
	void taskOneCopyCity();

	// вывод очереди
	void printDblQueue(DblList<Person>::Iterator<Person> iterator);

	// создание результирующего списка по городу
	bool selectionTaskOne(char* city, DblList<Person>::Iterator<Person> iterat, DblList<Person>& result);

public:

#pragma endregion

#pragma region Задача 2. Очередь нуждающихся в улучшении жилищных условий

	// Задача 2. Очередь нуждающихся в улучшении жилищных условий
	void task2();

private:

	// Скопировать в отдельный список всех нуждающихся с заданным количеством комнат
	void copyByRoom();

	// Скопировать в отдельный список по заданному диапазону площади
	void copyByArea();

	// вывод очереди
	void printQueue(Queue<Form>::Iterator<Form> iterator);

	// копирование в результирующую очередь по количеству комнат
	// возвращает false если нет рузультата
	bool copyResultByRoom(Queue<Form>::Iterator<Form> iter, Queue<Form>& result, int min, int max);

	// копирование в результирующую очередь по площади
	// возвращает false если нет рузультата
	bool copyResultByArea(Queue<Form>::Iterator<Form> iter, Queue<Form>& result, double min, double max);


public:
#pragma endregion
};

