// Структруры в языке C: это новый тип данных. 
// Это тип данных, определяемый пользователем
//
// Составной тип данных, каждая ячейка которого может иметь
// собственный тип, собственное имя.
// Доступ к таким ячейкам (полям) по имени
// Объявление структуры (не занимает памяти!!! не генерируется машинный код!!):
// struct ИМЯ_ТИПА_ТЭГ {
//     тип1 имя1;
//     тип2 имя2;
//     ...
//     типN имяN;
// };
//
// Определение структурной переменной или константы приводит к выделению
// памяти
// ИМЯ_ТИПА_ТЕГ имяПеременной1, ..., имяПеременнойN; 
#include "pch.h"
#include "Utils.h"
#include "Palette.h"

#include "TCylinder.h"     // для использования структуры TCylinder

#include "head.h"

int main()
{
    init(L"Домашнее задание на 19.05.2021");
	
    // структуры в WinAPI
    setColor(MAGENTA_ON_WHITE);
    cls();                           // очистка экрана
    setCursorVisible(false);    // отключение курсора

	// gotoXY() - позиционирование курсора по окну консоли
    setColor(WHITE_ON_MAGENTA);
    gotoXY(50, 11); cout << setw(20) << " ";
    gotoXY(50, 12); cout << "     Home Work      ";
    gotoXY(50, 13); cout << setw(20) << " ";
    Sleep(5000);

    gotoXY(0, 23);
    setCursorVisible(true);
    
    setColor(GRAY_ON_LTBLACK);
    cls();

	cout << "\n\n";

	menu();
    return 0;
} // main


// объектно-ориентированный подход к структурам
/*void demoOOPstructures()
{
	cout << "\n\tОбъектный подход в реализации структур:\n";

	// скалярная переменная - структура
	TDate date{ 12, 4, 1961 };
	cout << "\n\tСкалярная переменная: ";
	date.Output();
	cout << "\n";

	// проблема - при прямом  доступе к структуре можем записать
	// в поле произвольные, в том числе некорректные, данные  
	date.Day = -1;
	cout << "\n\tНекорректные данные : ";
	date.Output();
	cout << "\n\n";
	
	const int N = 5;
	TDate test[N] = {   // массив структур
		{ 31,  3, 2015 },
		{ 19,  9, 2012 },
	    {  5,  2, 1900 },
		{ 13, 11, 2011 },
	    {  2,  2, 2000 }
	};

	// цикл перебора массива структур
	cout << "\n\tМассив структур\n";
	for (int i = 0; i < N; i++) {
		cout << "\t";
		
		// на каждом элементе массива вызываем метод вывода структуры в консоль
		test[i].Output();

		// еще примеры вызовов методов на экземпляре структуры
		bool result = test[i].LeapYear();    // является ли год даты вискосным
		int d = test[i].DaysInMonth();       // сколько дней в месяце даты

		// вывод полученной информации - вискосный или не високосный год, количество дней в месяцк
		cout << " - " << left << setw(12) << (result ? "високосный" : "невисокосный") << right
			<< " - " << d << "\n";
	} // for i

} // demoOOPstructures
*/

#pragma region Задача на использование массива структур
/*
 * Создайте структуру, описывающий цилиндр TCylinder (поля радиус и высота,
 * тип double). Реализуйте методы для вычисляющие и возвращающие площадь и
 * объема цилиндра, метод вывода радиуса и высоты цилиндра в консоль.
 * Создайте массив из 5и цилиндров, радиус и высота – случайные числа. Выведите
 * массив в консоль в табличном виде: радиус и высота цилиндра, площадь и объем.
 * При выводе выделите цилиндр/цилиндры с объемом, равным минимальному.
 */


/*// служебные функции для решения задачи
void fill(TCylinder *cylinders, int n);
int indexMinVolume(TCylinder* cylinders, int n);
void showTable(const char *title, TCylinder* cylinders, int n);*/


// Создает массив из 5и цилиндров, радиус и высота – случайные числа. Выводим
// массив в консоль в табличном виде: радиус и высота цилиндра, площадь и объем.
// При выводе выделям цилиндр / цилиндры с объемом, равным минимальному
/*void taskDemo()
{
	// массив цилиндров для обработки 
	const int N = 5;
	TCylinder cylinders[N];

	// заполнение массива цилиндров начальными значениями
	fill(cylinders, N);

	// выводим таблицу цилиндров с выделением цилиндра/цилиндров с минимальным
	// объемом
	setColor(mainColor);
	ostringstream oss;
	oss << "\n\n\n"
	    << "\t    Задача. Обработка массива структур, описывающих цилиндр\n"
		<< "\t    Формирование массива структур, описывающих цилиндр, выделен цилиндр/цилиндры\n"
	    << "\t    с минимальным объемом.\n";
	showTable(oss.str().c_str(), cylinders, N);
} // task3


// заполнение массива цилиндров случайными значениями
void fill(TCylinder* cylinders, int n)
{
	for (int i = 0; i < n; ++i) {
		cylinders[i].radius = getRand(2., 10.);
		cylinders[i].height = getRand(2., 10.);
	} // for i
} // fill


// возвращает индекс цилиндра с минимальным объемом в массиве цилиндров cylinders
int indexMinVolume(TCylinder* cylinders, int n)
{
	// индекс цилиндра с минимальным объемом, значение минимального объема 
	int iMin = 0;
	double minVolume = cylinders[0].volume();

	// стандартный алгоритм поиска минимального значения
	for (int i = 1; i < n; ++i) {
		// для ускорения работы вычисляем объем для очередного цилиндра
		double curVolume = cylinders[i].volume();
		if (curVolume < minVolume) {
			minVolume = curVolume;
			iMin = i;
		} // if
	} // for i
	
	return iMin;
} // indexMinVolume
*/


#pragma endregion