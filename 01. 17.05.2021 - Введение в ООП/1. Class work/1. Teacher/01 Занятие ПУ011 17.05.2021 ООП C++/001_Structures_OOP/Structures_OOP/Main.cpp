// Структруры в языке C: это новый тип данных. 
// Это тип данных, определяемый пользователем
//
// Составной тип данных, каждая ячейка которого может иметь
// собственный тип, собственное имя.
// Доступ к таким ячейкам (полям) по имени
// Объявление структуры (не занимает памяти!!! не генерируется машинный код!!):
// struct ИМЯ_ТИПА_ТЭГ {
//     тип1 имя1;
//     тип2 имя2;
//     ...
//     типN имяN;
// };
//
// Определение структурной переменной или константы приводит к выделению
// памяти
// ИМЯ_ТИПА_ТЕГ имяПеременной1, ..., имяПеременнойN; 
#include "pch.h"
#include "Utils.h"
#include "Palette.h"

#include "TDate.h"         // для использования структуры TDate
#include "TCylinder.h"     // для использования структуры TCylinder

// Объявление структуры - типа SDATE - для хранения даты
struct SDATE {
	int day;       // поле для хранения дня
	int month;     // поле для хранения месяца
	int year;      // поле для хранения года
};   // <---------------- СИНТАКСИС !!!


// Объявление структуры - типа PERSON - для хранения 
// некоторых данных о человеке 
struct PERSON
{
    char name[50];
    char surname[60];
    char patronymic[70];
    int  age;
    double salary;
};



void demoOOPstructures();
void taskDemo();

int main()
{
    init(L"Занятие 17.05.2021 - структуры в C/C++, введение в ООП");
	
	/*
	// Определение переменной x - структуры типа SDATE
	// Определение и инициализация переменной y - структуры типа SDATE
	// Объявление - так говорят о задании структурного типа при помощи ключевого слова struct
	// Определение - так говорят об операции, приводящей к выделению памяти под переменную
	// При объявлении структурной переменной правильнее говорить об определении переменной
	SDATE x, y {31, 3, 2021}; // значения перечислены в порядке объявления полей

	// Доступ к полям структуры для скалярной переменной - операция "точка", знак операции "."
	x.day = 11;
	x.month = 4;
	x.year = 2021;

    // cout << x; 

	// Вывод/ввод/обработка - по полям
	cout << setfill('0') << setw(2) << x.day << "/" 
         << setw(2) << x.month << "/" 
         << setw(4) << x.year << "\n" << setfill(' ');
    printf("%02d/%02d/%04d\n", x.day, x.month, x.year);

	// Однотипные структуры можно присваивать друг другу
	// !! Только однотипные структуры !!
	x = y;

	// Вывод/ввод/обработка - по полям
	cout << x.day << "/" << x.month << "/" << x.year << "\n";

	cout << "\nВведите дату в формате д м г> ";
	cin >> y.day >> y.month >> y.year;
	printf("%02d/%02d/%04d\n", y.day, y.month, y.year);

	// Могут быть указатели на структуры и ссылочные переменные - структуры
	// Можно создавать динамические переменные - структуры 
	SDATE *ptr = new SDATE;

	// Операция "стрелка", знак операции "->" доступ к полю структуры через указатель
	// на структуру
	ptr->day = 27;
	ptr->month = 5;
	ptr->year = 2021;
    printf("%02d/%02d/%04d\n", ptr->day, ptr->month, ptr->year);
	// cout << ptr->day << "/" << ptr->month << "/" << ptr->year << "\n";

	// И, конечно, надо освобождать память, занятую динамической 
	// переменной - структурой
	delete ptr;

	// еще одна структрура
    PERSON person {"Вася", "Орлов", "Алексеевич", 29, 25000};
    cout << "\n\n" << person.surname << " " << person.name << " " << person.patronymic << " "
         << person.age << "  " << person.salary << "\n\n";
	*/
	
    // структуры в WinAPI
    setColor(MAGENTA_ON_WHITE);
    cls();                           // очистка экрана
    setCursorVisible(false);    // отключение курсора

	// gotoXY() - позиционирование курсора по окну консоли
    setColor(WHITE_ON_MAGENTA);
    gotoXY(50, 11); cout << setw(20) << " ";
    gotoXY(50, 12); cout << "    Привет, мир!    ";
    gotoXY(50, 13); cout << setw(20) << " ";
    Sleep(5000);

    gotoXY(0, 23);
    setCursorVisible(true);
    
    setColor(GRAY_ON_LTBLACK);
    cls();

	// демонстрация объектно-ориентированного подхода при работе со структурами
	demoOOPstructures();

	// демонстрация решения задачи на использование массива структур
	taskDemo();

	cout << "\n\n";
    return 0;
} // main


// объектно-ориентированный подход к структурам
void demoOOPstructures()
{
	cout << "\n\tОбъектный подход в реализации структур:\n";

	// скалярная переменная - структура
	TDate date{ 12, 4, 1961 };
	cout << "\n\tСкалярная переменная: ";
	date.Output();
	cout << "\n";

	// проблема - при прямом  доступе к структуре можем записать
	// в поле произвольные, в том числе некорректные, данные  
	date.Day = -1;
	cout << "\n\tНекорректные данные : ";
	date.Output();
	cout << "\n\n";
	
	const int N = 5;
	TDate test[N] = {   // массив структур
		{ 31,  3, 2015 },
		{ 19,  9, 2012 },
	    {  5,  2, 1900 },
		{ 13, 11, 2011 },
	    {  2,  2, 2000 }
	};

	// цикл перебора массива структур
	cout << "\n\tМассив структур\n";
	for (int i = 0; i < N; i++) {
		cout << "\t";
		
		// на каждом элементе массива вызываем метод вывода структуры в консоль
		test[i].Output();

		// еще примеры вызовов методов на экземпляре структуры
		bool result = test[i].LeapYear();    // является ли год даты вискосным
		int d = test[i].DaysInMonth();       // сколько дней в месяце даты

		// вывод полученной информации - вискосный или не високосный год, количество дней в месяцк
		cout << " - " << left << setw(12) << (result ? "високосный" : "невисокосный") << right
			<< " - " << d << "\n";
	} // for i

} // demoOOPstructures


#pragma region Задача на использование массива структур
/*
 * Создайте структуру, описывающий цилиндр TCylinder (поля радиус и высота,
 * тип double). Реализуйте методы для вычисляющие и возвращающие площадь и
 * объема цилиндра, метод вывода радиуса и высоты цилиндра в консоль.
 * Создайте массив из 5и цилиндров, радиус и высота – случайные числа. Выведите
 * массив в консоль в табличном виде: радиус и высота цилиндра, площадь и объем.
 * При выводе выделите цилиндр/цилиндры с объемом, равным минимальному.
 */


// служебные функции для решения задачи
void fill(TCylinder *cylinders, int n);
int indexMinVolume(TCylinder* cylinders, int n);
void showTable(const char *title, TCylinder* cylinders, int n);


// Создает массив из 5и цилиндров, радиус и высота – случайные числа. Выводим
// массив в консоль в табличном виде: радиус и высота цилиндра, площадь и объем.
// При выводе выделям цилиндр / цилиндры с объемом, равным минимальному
void taskDemo()
{
	// массив цилиндров для обработки 
	const int N = 5;
	TCylinder cylinders[N];

	// заполнение массива цилиндров начальными значениями
	fill(cylinders, N);

	// выводим таблицу цилиндров с выделением цилиндра/цилиндров с минимальным
	// объемом
	setColor(mainColor);
	ostringstream oss;
	oss << "\n\n\n"
	    << "\t    Задача. Обработка массива структур, описывающих цилиндр\n"
		<< "\t    Формирование массива структур, описывающих цилиндр, выделен цилиндр/цилиндры\n"
	    << "\t    с минимальным объемом.\n";
	showTable(oss.str().c_str(), cylinders, N);
} // task3


// заполнение массива цилиндров случайными значениями
void fill(TCylinder* cylinders, int n)
{
	for (int i = 0; i < n; ++i) {
		cylinders[i].radius = getRand(2., 10.);
		cylinders[i].height = getRand(2., 10.);
	} // for i
} // fill


// возвращает индекс цилиндра с минимальным объемом в массиве цилиндров cylinders
int indexMinVolume(TCylinder* cylinders, int n)
{
	// индекс цилиндра с минимальным объемом, значение минимального объема 
	int iMin = 0;
	double minVolume = cylinders[0].volume();

	// стандартный алгоритм поиска минимального значения
	for (int i = 1; i < n; ++i) {
		// для ускорения работы вычисляем объем для очередного цилиндра
		double curVolume = cylinders[i].volume();
		if (curVolume < minVolume) {
			minVolume = curVolume;
			iMin = i;
		} // if
	} // for i
	
	return iMin;
} // indexMinVolume


// вывод массива цилиндров в табличном формате, горизонтальная линия: — Alt+0151
void showTable(const char* title, TCylinder* cylinders, int n)
{
	// поиск минимального объема цилиндра
	double minVolume = cylinders[indexMinVolume(cylinders, n)].volume();
	
	cout<< title
	    << "\t    +—————+—————————————————+————————————————+—————————————————————————————————+\n"
		<< "\t    |  N  |    Радиус, R    |    Высота, H   |   Площадь, S   |    Объем, V    |\n"
		<< "\t    +—————+—————————————————+————————————————+—————————————————————————————————+\n";

	// выводим строки таблицы цилиндров, с выделением цветом
	// строки с минимальным объемом, перед и после этой строки
	// выводим цветовые "хвостики"
	for (int i = 0; i < n; ++i) {
		cout << "\t";
		setColor(cylinders[i].volume() == minVolume ? acctColor : mainColor);
		cout << "    ";
		cylinders[i].tableRow(i+1);
		cout << "    ";
		setColor(mainColor);
		cout << "\n";
	} // for i
	cout << "\t    +—————+—————————————————+————————————————+—————————————————————————————————+\n";
} // showTable
#pragma endregion